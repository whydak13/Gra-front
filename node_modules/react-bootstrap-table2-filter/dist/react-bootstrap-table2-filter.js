(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactBootstrapTable2Filter"] = factory(require("react"));
	else
		root["ReactBootstrapTable2Filter"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var LIKE = exports.LIKE = 'LIKE';
var EQ = exports.EQ = '=';
var NE = exports.NE = '!=';
var GT = exports.GT = '>';
var GE = exports.GE = '>=';
var LT = exports.LT = '<';
var LE = exports.LE = '<=';

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var FILTER_TYPE = exports.FILTER_TYPE = {
  TEXT: 'TEXT',
  SELECT: 'SELECT',
  MULTISELECT: 'MULTISELECT',
  NUMBER: 'NUMBER',
  DATE: 'DATE'
};

var FILTER_DELAY = exports.FILTER_DELAY = 500;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(6)();
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.customFilter = exports.dateFilter = exports.numberFilter = exports.multiSelectFilter = exports.selectFilter = exports.textFilter = exports.Comparator = exports.FILTER_TYPES = undefined;

var _text = __webpack_require__(5);

var _text2 = _interopRequireDefault(_text);

var _select = __webpack_require__(10);

var _select2 = _interopRequireDefault(_select);

var _multiselect = __webpack_require__(11);

var _multiselect2 = _interopRequireDefault(_multiselect);

var _number = __webpack_require__(12);

var _number2 = _interopRequireDefault(_number);

var _date = __webpack_require__(13);

var _date2 = _interopRequireDefault(_date);

var _context = __webpack_require__(14);

var _context2 = _interopRequireDefault(_context);

var _comparison = __webpack_require__(0);

var Comparison = _interopRequireWildcard(_comparison);

var _const = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    createContext: _context2.default,
    options: options
  };
};

var FILTER_TYPES = exports.FILTER_TYPES = _const.FILTER_TYPE;

var Comparator = exports.Comparator = Comparison;

var textFilter = exports.textFilter = function textFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    Filter: _text2.default,
    props: props
  };
};

var selectFilter = exports.selectFilter = function selectFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    Filter: _select2.default,
    props: props
  };
};

var multiSelectFilter = exports.multiSelectFilter = function multiSelectFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    Filter: _multiselect2.default,
    props: props
  };
};

var numberFilter = exports.numberFilter = function numberFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    Filter: _number2.default,
    props: props
  };
};

var dateFilter = exports.dateFilter = function dateFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    Filter: _date2.default,
    props: props
  };
};

var customFilter = exports.customFilter = function customFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    props: props
  };
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _comparison = __webpack_require__(0);

var _const = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint react/prop-types: 0 */
/* eslint no-return-assign: 0 */
/* eslint camelcase: 0 */


var TextFilter = function (_Component) {
  _inherits(TextFilter, _Component);

  function TextFilter(props) {
    _classCallCheck(this, TextFilter);

    var _this = _possibleConstructorReturn(this, (TextFilter.__proto__ || Object.getPrototypeOf(TextFilter)).call(this, props));

    _this.filter = _this.filter.bind(_this);
    _this.handleClick = _this.handleClick.bind(_this);
    _this.timeout = null;
    function getDefaultValue() {
      if (props.filterState && typeof props.filterState.filterVal !== 'undefined') {
        return props.filterState.filterVal;
      }
      return props.defaultValue;
    }
    _this.state = {
      value: getDefaultValue()
    };
    return _this;
  }

  _createClass(TextFilter, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var _props = this.props,
          onFilter = _props.onFilter,
          getFilter = _props.getFilter,
          column = _props.column;

      var defaultValue = this.input.value;

      if (defaultValue) {
        onFilter(this.props.column, _const.FILTER_TYPE.TEXT, true)(defaultValue);
      }

      // export onFilter function to allow users to access
      if (getFilter) {
        getFilter(function (filterVal) {
          _this2.setState(function () {
            return { value: filterVal };
          });
          onFilter(column, _const.FILTER_TYPE.TEXT)(filterVal);
        });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.cleanTimer();
    }
  }, {
    key: 'UNSAFE_componentWillReceiveProps',
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (nextProps.defaultValue !== this.props.defaultValue) {
        this.applyFilter(nextProps.defaultValue);
      }
    }
  }, {
    key: 'filter',
    value: function filter(e) {
      var _this3 = this;

      e.stopPropagation();
      this.cleanTimer();
      var filterValue = e.target.value;
      this.setState(function () {
        return { value: filterValue };
      });
      this.timeout = setTimeout(function () {
        _this3.props.onFilter(_this3.props.column, _const.FILTER_TYPE.TEXT)(filterValue);
      }, this.props.delay);
    }
  }, {
    key: 'cleanTimer',
    value: function cleanTimer() {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
    }
  }, {
    key: 'cleanFiltered',
    value: function cleanFiltered() {
      var value = this.props.defaultValue;
      this.setState(function () {
        return { value: value };
      });
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.TEXT)(value);
    }
  }, {
    key: 'applyFilter',
    value: function applyFilter(filterText) {
      this.setState(function () {
        return { value: filterText };
      });
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.TEXT)(filterText);
    }
  }, {
    key: 'handleClick',
    value: function handleClick(e) {
      e.stopPropagation();
      if (this.props.onClick) {
        this.props.onClick(e);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props2 = this.props,
          id = _props2.id,
          placeholder = _props2.placeholder,
          _props2$column = _props2.column,
          dataField = _props2$column.dataField,
          text = _props2$column.text,
          style = _props2.style,
          className = _props2.className,
          onFilter = _props2.onFilter,
          caseSensitive = _props2.caseSensitive,
          defaultValue = _props2.defaultValue,
          getFilter = _props2.getFilter,
          filterState = _props2.filterState,
          rest = _objectWithoutProperties(_props2, ['id', 'placeholder', 'column', 'style', 'className', 'onFilter', 'caseSensitive', 'defaultValue', 'getFilter', 'filterState']);

      var elmId = 'text-filter-column-' + dataField + (id ? '-' + id : '');

      return _react2.default.createElement(
        'label',
        {
          className: 'filter-label',
          htmlFor: elmId
        },
        _react2.default.createElement(
          'span',
          { className: 'sr-only' },
          'Filter by ',
          text
        ),
        _react2.default.createElement('input', _extends({}, rest, {
          ref: function ref(n) {
            return _this4.input = n;
          },
          type: 'text',
          id: elmId,
          className: 'filter text-filter form-control ' + className,
          style: style,
          onChange: this.filter,
          onClick: this.handleClick,
          placeholder: placeholder || 'Enter ' + text + '...',
          value: this.state.value
        }))
      );
    }
  }]);

  return TextFilter;
}(_react.Component);

TextFilter.propTypes = {
  onFilter: _propTypes.PropTypes.func.isRequired,
  column: _propTypes.PropTypes.object.isRequired,
  id: _propTypes.PropTypes.string,
  filterState: _propTypes.PropTypes.object,
  comparator: _propTypes.PropTypes.oneOf([_comparison.LIKE, _comparison.EQ]),
  defaultValue: _propTypes.PropTypes.string,
  delay: _propTypes.PropTypes.number,
  placeholder: _propTypes.PropTypes.string,
  style: _propTypes.PropTypes.object,
  className: _propTypes.PropTypes.string,
  caseSensitive: _propTypes.PropTypes.bool,
  getFilter: _propTypes.PropTypes.func
};

TextFilter.defaultProps = {
  delay: _const.FILTER_DELAY,
  filterState: {},
  defaultValue: '',
  caseSensitive: false,
  id: null
};

exports.default = TextFilter;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(7);
var invariant = __webpack_require__(8);
var ReactPropTypesSecret = __webpack_require__(9);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _comparison = __webpack_require__(0);

var _const = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint no-return-assign: 0 */
/* eslint react/no-unused-prop-types: 0 */
/* eslint class-methods-use-this: 0 */


function optionsEquals(currOpts, prevOpts) {
  if (Array.isArray(currOpts)) {
    if (currOpts.length === prevOpts.length) {
      for (var i = 0; i < currOpts.length; i += 1) {
        if (currOpts[i].value !== prevOpts[i].value || currOpts[i].label !== prevOpts[i].label) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  var keys = Object.keys(currOpts);
  for (var _i = 0; _i < keys.length; _i += 1) {
    if (currOpts[keys[_i]] !== prevOpts[keys[_i]]) {
      return false;
    }
  }
  return Object.keys(currOpts).length === Object.keys(prevOpts).length;
}

function getOptionValue(options, key) {
  if (Array.isArray(options)) {
    var result = options.filter(function (_ref) {
      var label = _ref.label;
      return label === key;
    }).map(function (_ref2) {
      var value = _ref2.value;
      return value;
    });
    return result[0];
  }
  return options[key];
}

var SelectFilter = function (_Component) {
  _inherits(SelectFilter, _Component);

  function SelectFilter(props) {
    _classCallCheck(this, SelectFilter);

    var _this = _possibleConstructorReturn(this, (SelectFilter.__proto__ || Object.getPrototypeOf(SelectFilter)).call(this, props));

    _this.filter = _this.filter.bind(_this);
    _this.options = _this.getOptions(props);
    var isSelected = getOptionValue(_this.options, _this.getDefaultValue()) !== undefined;
    _this.state = { isSelected: isSelected };
    return _this;
  }

  _createClass(SelectFilter, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var _props = this.props,
          column = _props.column,
          onFilter = _props.onFilter,
          getFilter = _props.getFilter;


      var value = this.selectInput.value;
      if (value && value !== '') {
        onFilter(column, _const.FILTER_TYPE.SELECT, true)(value);
      }

      // export onFilter function to allow users to access
      if (getFilter) {
        getFilter(function (filterVal) {
          _this2.setState(function () {
            return { isSelected: filterVal !== '' };
          });
          _this2.selectInput.value = filterVal;

          onFilter(column, _const.FILTER_TYPE.SELECT)(filterVal);
        });
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var needFilter = false;
      var _props2 = this.props,
          column = _props2.column,
          onFilter = _props2.onFilter,
          defaultValue = _props2.defaultValue;

      var nextOptions = this.getOptions(this.props);
      if (defaultValue !== prevProps.defaultValue) {
        needFilter = true;
      } else if (!optionsEquals(nextOptions, this.options)) {
        this.options = nextOptions;
        needFilter = true;
      }
      if (needFilter) {
        var value = this.selectInput.value;
        if (value) {
          onFilter(column, _const.FILTER_TYPE.SELECT)(value);
        }
      }
    }
  }, {
    key: 'getOptions',
    value: function getOptions(props) {
      return typeof props.options === 'function' ? props.options(props.column) : props.options;
    }
  }, {
    key: 'getDefaultValue',
    value: function getDefaultValue() {
      var _props3 = this.props,
          filterState = _props3.filterState,
          defaultValue = _props3.defaultValue;

      if (filterState && typeof filterState.filterVal !== 'undefined') {
        return filterState.filterVal;
      }
      return defaultValue;
    }
  }, {
    key: 'cleanFiltered',
    value: function cleanFiltered() {
      var value = this.props.defaultValue !== undefined ? this.props.defaultValue : '';
      this.setState(function () {
        return { isSelected: value !== '' };
      });
      this.selectInput.value = value;
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.SELECT)(value);
    }
  }, {
    key: 'applyFilter',
    value: function applyFilter(value) {
      this.selectInput.value = value;
      this.setState(function () {
        return { isSelected: value !== '' };
      });
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.SELECT)(value);
    }
  }, {
    key: 'filter',
    value: function filter(e) {
      var value = e.target.value;

      this.setState(function () {
        return { isSelected: value !== '' };
      });
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.SELECT)(value);
    }
  }, {
    key: 'renderOptions',
    value: function renderOptions() {
      var optionTags = [];
      var options = this.options;
      var _props4 = this.props,
          placeholder = _props4.placeholder,
          column = _props4.column,
          withoutEmptyOption = _props4.withoutEmptyOption;

      if (!withoutEmptyOption) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: '-1', value: '' },
          placeholder || 'Select ' + column.text + '...'
        ));
      }
      if (Array.isArray(options)) {
        options.forEach(function (_ref3) {
          var value = _ref3.value,
              label = _ref3.label;
          return optionTags.push(_react2.default.createElement(
            'option',
            { key: value, value: value },
            label
          ));
        });
      } else {
        Object.keys(options).forEach(function (key) {
          return optionTags.push(_react2.default.createElement(
            'option',
            { key: key, value: key },
            options[key]
          ));
        });
      }
      return optionTags;
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props5 = this.props,
          id = _props5.id,
          style = _props5.style,
          className = _props5.className,
          defaultValue = _props5.defaultValue,
          onFilter = _props5.onFilter,
          column = _props5.column,
          options = _props5.options,
          comparator = _props5.comparator,
          withoutEmptyOption = _props5.withoutEmptyOption,
          caseSensitive = _props5.caseSensitive,
          getFilter = _props5.getFilter,
          filterState = _props5.filterState,
          rest = _objectWithoutProperties(_props5, ['id', 'style', 'className', 'defaultValue', 'onFilter', 'column', 'options', 'comparator', 'withoutEmptyOption', 'caseSensitive', 'getFilter', 'filterState']);

      var selectClass = 'filter select-filter form-control ' + className + ' ' + (this.state.isSelected ? '' : 'placeholder-selected');
      var elmId = 'select-filter-column-' + column.dataField + (id ? '-' + id : '');

      return _react2.default.createElement(
        'label',
        {
          className: 'filter-label',
          htmlFor: elmId
        },
        _react2.default.createElement(
          'span',
          { className: 'sr-only' },
          'Filter by ',
          column.text
        ),
        _react2.default.createElement(
          'select',
          _extends({}, rest, {
            ref: function ref(n) {
              return _this3.selectInput = n;
            },
            id: elmId,
            style: style,
            className: selectClass,
            onChange: this.filter,
            onClick: function onClick(e) {
              return e.stopPropagation();
            },
            defaultValue: this.getDefaultValue() || ''
          }),
          this.renderOptions()
        )
      );
    }
  }]);

  return SelectFilter;
}(_react.Component);

SelectFilter.propTypes = {
  onFilter: _propTypes2.default.func.isRequired,
  column: _propTypes2.default.object.isRequired,
  id: _propTypes2.default.string,
  filterState: _propTypes2.default.object,
  options: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.array]).isRequired,
  comparator: _propTypes2.default.oneOf([_comparison.LIKE, _comparison.EQ]),
  placeholder: _propTypes2.default.string,
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  withoutEmptyOption: _propTypes2.default.bool,
  defaultValue: _propTypes2.default.any,
  caseSensitive: _propTypes2.default.bool,
  getFilter: _propTypes2.default.func
};

SelectFilter.defaultProps = {
  defaultValue: '',
  filterState: {},
  className: '',
  withoutEmptyOption: false,
  comparator: _comparison.EQ,
  caseSensitive: true,
  id: null
};

exports.default = SelectFilter;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _comparison = __webpack_require__(0);

var _const = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint no-return-assign: 0 */
/* eslint no-param-reassign: 0 */
/* eslint react/no-unused-prop-types: 0 */


function optionsEquals(currOpts, prevOpts) {
  var keys = Object.keys(currOpts);
  for (var i = 0; i < keys.length; i += 1) {
    if (currOpts[keys[i]] !== prevOpts[keys[i]]) {
      return false;
    }
  }
  return Object.keys(currOpts).length === Object.keys(prevOpts).length;
}

var getSelections = function getSelections(container) {
  if (container.selectedOptions) {
    return Array.from(container.selectedOptions).map(function (item) {
      return item.value;
    });
  }
  var selections = [];
  var totalLen = container.options.length;
  for (var i = 0; i < totalLen; i += 1) {
    var option = container.options.item(i);
    if (option.selected) selections.push(option.value);
  }
  return selections;
};

var MultiSelectFilter = function (_Component) {
  _inherits(MultiSelectFilter, _Component);

  function MultiSelectFilter(props) {
    _classCallCheck(this, MultiSelectFilter);

    var _this = _possibleConstructorReturn(this, (MultiSelectFilter.__proto__ || Object.getPrototypeOf(MultiSelectFilter)).call(this, props));

    _this.filter = _this.filter.bind(_this);
    _this.applyFilter = _this.applyFilter.bind(_this);
    var isSelected = props.defaultValue.map(function (item) {
      return props.options[item];
    }).length > 0;
    _this.state = { isSelected: isSelected };
    return _this;
  }

  _createClass(MultiSelectFilter, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var getFilter = this.props.getFilter;


      var value = getSelections(this.selectInput);
      if (value && value.length > 0) {
        this.applyFilter(value);
      }

      // export onFilter function to allow users to access
      if (getFilter) {
        getFilter(function (filterVal) {
          _this2.selectInput.value = filterVal;
          _this2.applyFilter(filterVal);
        });
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var needFilter = false;
      if (this.props.defaultValue !== prevProps.defaultValue) {
        needFilter = true;
      } else if (!optionsEquals(this.props.options, prevProps.options)) {
        needFilter = true;
      }
      if (needFilter) {
        this.applyFilter(getSelections(this.selectInput));
      }
    }
  }, {
    key: 'getDefaultValue',
    value: function getDefaultValue() {
      var _props = this.props,
          filterState = _props.filterState,
          defaultValue = _props.defaultValue;

      if (filterState && typeof filterState.filterVal !== 'undefined') {
        return filterState.filterVal;
      }
      return defaultValue;
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      var optionTags = [];
      var _props2 = this.props,
          options = _props2.options,
          placeholder = _props2.placeholder,
          column = _props2.column,
          withoutEmptyOption = _props2.withoutEmptyOption;

      if (!withoutEmptyOption) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: '-1', value: '' },
          placeholder || 'Select ' + column.text + '...'
        ));
      }
      Object.keys(options).forEach(function (key) {
        return optionTags.push(_react2.default.createElement(
          'option',
          { key: key, value: key },
          options[key]
        ));
      });
      return optionTags;
    }
  }, {
    key: 'cleanFiltered',
    value: function cleanFiltered() {
      var value = this.props.defaultValue !== undefined ? this.props.defaultValue : [];
      this.selectInput.value = value;
      this.applyFilter(value);
    }
  }, {
    key: 'applyFilter',
    value: function applyFilter(value) {
      if (value.length === 1 && value[0] === '') {
        value = [];
      }
      this.setState(function () {
        return { isSelected: value.length > 0 };
      });
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.MULTISELECT)(value);
    }
  }, {
    key: 'filter',
    value: function filter(e) {
      var value = getSelections(e.target);
      this.applyFilter(value);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props3 = this.props,
          id = _props3.id,
          style = _props3.style,
          className = _props3.className,
          filterState = _props3.filterState,
          defaultValue = _props3.defaultValue,
          onFilter = _props3.onFilter,
          column = _props3.column,
          options = _props3.options,
          comparator = _props3.comparator,
          withoutEmptyOption = _props3.withoutEmptyOption,
          caseSensitive = _props3.caseSensitive,
          getFilter = _props3.getFilter,
          rest = _objectWithoutProperties(_props3, ['id', 'style', 'className', 'filterState', 'defaultValue', 'onFilter', 'column', 'options', 'comparator', 'withoutEmptyOption', 'caseSensitive', 'getFilter']);

      var selectClass = 'filter select-filter form-control ' + className + ' ' + (this.state.isSelected ? '' : 'placeholder-selected');
      var elmId = 'multiselect-filter-column-' + column.dataField + (id ? '-' + id : '');

      return _react2.default.createElement(
        'label',
        {
          className: 'filter-label',
          htmlFor: elmId
        },
        _react2.default.createElement(
          'span',
          { className: 'sr-only' },
          'Filter by ',
          column.text
        ),
        _react2.default.createElement(
          'select',
          _extends({}, rest, {
            ref: function ref(n) {
              return _this3.selectInput = n;
            },
            id: elmId,
            style: style,
            multiple: true,
            className: selectClass,
            onChange: this.filter,
            onClick: function onClick(e) {
              return e.stopPropagation();
            },
            defaultValue: this.getDefaultValue()
          }),
          this.getOptions()
        )
      );
    }
  }]);

  return MultiSelectFilter;
}(_react.Component);

MultiSelectFilter.propTypes = {
  onFilter: _propTypes2.default.func.isRequired,
  column: _propTypes2.default.object.isRequired,
  options: _propTypes2.default.object.isRequired,
  id: _propTypes2.default.string,
  filterState: _propTypes2.default.object,
  comparator: _propTypes2.default.oneOf([_comparison.LIKE, _comparison.EQ]),
  placeholder: _propTypes2.default.string,
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  withoutEmptyOption: _propTypes2.default.bool,
  defaultValue: _propTypes2.default.array,
  caseSensitive: _propTypes2.default.bool,
  getFilter: _propTypes2.default.func
};

MultiSelectFilter.defaultProps = {
  defaultValue: [],
  filterState: {},
  className: '',
  withoutEmptyOption: false,
  comparator: _comparison.EQ,
  caseSensitive: true,
  id: null
};

exports.default = MultiSelectFilter;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _comparison = __webpack_require__(0);

var Comparator = _interopRequireWildcard(_comparison);

var _const = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint jsx-a11y/no-static-element-interactions: 0 */
/* eslint react/require-default-props: 0 */
/* eslint no-return-assign: 0 */

var legalComparators = [Comparator.EQ, Comparator.NE, Comparator.GT, Comparator.GE, Comparator.LT, Comparator.LE];

var NumberFilter = function (_Component) {
  _inherits(NumberFilter, _Component);

  function NumberFilter(props) {
    _classCallCheck(this, NumberFilter);

    var _this = _possibleConstructorReturn(this, (NumberFilter.__proto__ || Object.getPrototypeOf(NumberFilter)).call(this, props));

    _this.comparators = props.comparators || legalComparators;
    _this.timeout = null;
    var isSelected = props.defaultValue !== undefined && props.defaultValue.number !== undefined;
    if (props.options && isSelected) {
      isSelected = props.options.indexOf(props.defaultValue.number) > -1;
    }
    _this.state = { isSelected: isSelected };
    _this.onChangeNumber = _this.onChangeNumber.bind(_this);
    _this.onChangeNumberSet = _this.onChangeNumberSet.bind(_this);
    _this.onChangeComparator = _this.onChangeComparator.bind(_this);
    return _this;
  }

  _createClass(NumberFilter, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var _props = this.props,
          column = _props.column,
          onFilter = _props.onFilter,
          getFilter = _props.getFilter;

      var comparator = this.numberFilterComparator.value;
      var number = this.numberFilter.value;
      if (comparator && number) {
        onFilter(column, _const.FILTER_TYPE.NUMBER, true)({ number: number, comparator: comparator });
      }

      // export onFilter function to allow users to access
      if (getFilter) {
        getFilter(function (filterVal) {
          _this2.setState(function () {
            return { isSelected: filterVal !== '' };
          });
          _this2.numberFilterComparator.value = filterVal.comparator;
          _this2.numberFilter.value = filterVal.number;

          onFilter(column, _const.FILTER_TYPE.NUMBER)({
            number: filterVal.number,
            comparator: filterVal.comparator
          });
        });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearTimeout(this.timeout);
    }
  }, {
    key: 'onChangeNumber',
    value: function onChangeNumber(e) {
      var _props2 = this.props,
          delay = _props2.delay,
          column = _props2.column,
          onFilter = _props2.onFilter;

      var comparator = this.numberFilterComparator.value;
      if (comparator === '') {
        return;
      }
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      var filterValue = e.target.value;
      this.timeout = setTimeout(function () {
        onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: filterValue, comparator: comparator });
      }, delay);
    }
  }, {
    key: 'onChangeNumberSet',
    value: function onChangeNumberSet(e) {
      var _props3 = this.props,
          column = _props3.column,
          onFilter = _props3.onFilter;

      var comparator = this.numberFilterComparator.value;
      var value = e.target.value;

      this.setState(function () {
        return { isSelected: value !== '' };
      });
      // if (comparator === '') {
      //   return;
      // }
      onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: value, comparator: comparator });
    }
  }, {
    key: 'onChangeComparator',
    value: function onChangeComparator(e) {
      var _props4 = this.props,
          column = _props4.column,
          onFilter = _props4.onFilter;

      var value = this.numberFilter.value;
      var comparator = e.target.value;
      // if (value === '') {
      //   return;
      // }
      onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: value, comparator: comparator });
    }
  }, {
    key: 'getDefaultComparator',
    value: function getDefaultComparator() {
      var _props5 = this.props,
          defaultValue = _props5.defaultValue,
          filterState = _props5.filterState;

      if (filterState && filterState.filterVal) {
        return filterState.filterVal.comparator;
      }
      if (defaultValue && defaultValue.comparator) {
        return defaultValue.comparator;
      }
      return '';
    }
  }, {
    key: 'getDefaultValue',
    value: function getDefaultValue() {
      var _props6 = this.props,
          defaultValue = _props6.defaultValue,
          filterState = _props6.filterState;

      if (filterState && filterState.filterVal) {
        return filterState.filterVal.number;
      }
      if (defaultValue && defaultValue.number) {
        return defaultValue.number;
      }
      return '';
    }
  }, {
    key: 'getComparatorOptions',
    value: function getComparatorOptions() {
      var optionTags = [];
      var withoutEmptyComparatorOption = this.props.withoutEmptyComparatorOption;

      if (!withoutEmptyComparatorOption) {
        optionTags.push(_react2.default.createElement('option', { key: '-1' }));
      }
      for (var i = 0; i < this.comparators.length; i += 1) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: i, value: this.comparators[i] },
          this.comparators[i]
        ));
      }
      return optionTags;
    }
  }, {
    key: 'getNumberOptions',
    value: function getNumberOptions() {
      var optionTags = [];
      var _props7 = this.props,
          options = _props7.options,
          column = _props7.column,
          withoutEmptyNumberOption = _props7.withoutEmptyNumberOption;

      if (!withoutEmptyNumberOption) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: '-1', value: '' },
          this.props.placeholder || 'Select ' + column.text + '...'
        ));
      }
      for (var i = 0; i < options.length; i += 1) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: i, value: options[i] },
          options[i]
        ));
      }
      return optionTags;
    }
  }, {
    key: 'applyFilter',
    value: function applyFilter(filterObj) {
      var _props8 = this.props,
          column = _props8.column,
          onFilter = _props8.onFilter;
      var number = filterObj.number,
          comparator = filterObj.comparator;

      this.setState(function () {
        return { isSelected: number !== '' };
      });
      this.numberFilterComparator.value = comparator;
      this.numberFilter.value = number;
      onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: number, comparator: comparator });
    }
  }, {
    key: 'cleanFiltered',
    value: function cleanFiltered() {
      var _props9 = this.props,
          column = _props9.column,
          onFilter = _props9.onFilter,
          defaultValue = _props9.defaultValue;

      var value = defaultValue ? defaultValue.number : '';
      var comparator = defaultValue ? defaultValue.comparator : '';
      this.setState(function () {
        return { isSelected: value !== '' };
      });
      this.numberFilterComparator.value = comparator;
      this.numberFilter.value = value;
      onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: value, comparator: comparator });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var isSelected = this.state.isSelected;
      var _props10 = this.props,
          id = _props10.id,
          column = _props10.column,
          options = _props10.options,
          style = _props10.style,
          className = _props10.className,
          numberStyle = _props10.numberStyle,
          numberClassName = _props10.numberClassName,
          comparatorStyle = _props10.comparatorStyle,
          comparatorClassName = _props10.comparatorClassName,
          placeholder = _props10.placeholder;

      var selectClass = '\n      select-filter \n      number-filter-input \n      form-control \n      ' + numberClassName + ' \n      ' + (!isSelected ? 'placeholder-selected' : '') + '\n    ';

      var comparatorElmId = 'number-filter-comparator-' + column.dataField + (id ? '-' + id : '');
      var inputElmId = 'number-filter-column-' + column.dataField + (id ? '-' + id : '');

      return _react2.default.createElement(
        'div',
        {
          onClick: function onClick(e) {
            return e.stopPropagation();
          },
          className: 'filter number-filter ' + className,
          style: style
        },
        _react2.default.createElement(
          'label',
          {
            className: 'filter-label',
            htmlFor: comparatorElmId
          },
          _react2.default.createElement(
            'span',
            { className: 'sr-only' },
            'Filter comparator'
          ),
          _react2.default.createElement(
            'select',
            {
              ref: function ref(n) {
                return _this3.numberFilterComparator = n;
              },
              style: comparatorStyle,
              id: comparatorElmId,
              className: 'number-filter-comparator form-control ' + comparatorClassName,
              onChange: this.onChangeComparator,
              defaultValue: this.getDefaultComparator()
            },
            this.getComparatorOptions()
          )
        ),
        options ? _react2.default.createElement(
          'label',
          {
            className: 'filter-label',
            htmlFor: inputElmId
          },
          _react2.default.createElement(
            'span',
            { className: 'sr-only' },
            'Select ' + column.text
          ),
          _react2.default.createElement(
            'select',
            {
              ref: function ref(n) {
                return _this3.numberFilter = n;
              },
              id: inputElmId,
              style: numberStyle,
              className: selectClass,
              onChange: this.onChangeNumberSet,
              defaultValue: this.getDefaultValue()
            },
            this.getNumberOptions()
          )
        ) : _react2.default.createElement(
          'label',
          { htmlFor: inputElmId },
          _react2.default.createElement(
            'span',
            { className: 'sr-only' },
            'Enter ' + column.text
          ),
          _react2.default.createElement('input', {
            ref: function ref(n) {
              return _this3.numberFilter = n;
            },
            id: inputElmId,
            type: 'number',
            style: numberStyle,
            className: 'number-filter-input form-control ' + numberClassName,
            placeholder: placeholder || 'Enter ' + column.text + '...',
            onChange: this.onChangeNumber,
            defaultValue: this.getDefaultValue()
          })
        )
      );
    }
  }]);

  return NumberFilter;
}(_react.Component);

NumberFilter.propTypes = {
  onFilter: _propTypes2.default.func.isRequired,
  column: _propTypes2.default.object.isRequired,
  id: _propTypes2.default.string,
  filterState: _propTypes2.default.object,
  options: _propTypes2.default.arrayOf(_propTypes2.default.number),
  defaultValue: _propTypes2.default.shape({
    number: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
    comparator: _propTypes2.default.oneOf([].concat(legalComparators, ['']))
  }),
  delay: _propTypes2.default.number,
  /* eslint consistent-return: 0 */
  comparators: function comparators(props, propName) {
    if (!props[propName]) {
      return;
    }
    for (var i = 0; i < props[propName].length; i += 1) {
      var comparatorIsValid = false;
      for (var j = 0; j < legalComparators.length; j += 1) {
        if (legalComparators[j] === props[propName][i] || props[propName][i] === '') {
          comparatorIsValid = true;
          break;
        }
      }
      if (!comparatorIsValid) {
        return new Error('Number comparator provided is not supported.\n          Use only ' + legalComparators);
      }
    }
  },
  placeholder: _propTypes2.default.string,
  withoutEmptyComparatorOption: _propTypes2.default.bool,
  withoutEmptyNumberOption: _propTypes2.default.bool,
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  comparatorStyle: _propTypes2.default.object,
  comparatorClassName: _propTypes2.default.string,
  numberStyle: _propTypes2.default.object,
  numberClassName: _propTypes2.default.string,
  getFilter: _propTypes2.default.func
};

NumberFilter.defaultProps = {
  delay: _const.FILTER_DELAY,
  options: undefined,
  defaultValue: {
    number: undefined,
    comparator: ''
  },
  filterState: {},
  withoutEmptyComparatorOption: false,
  withoutEmptyNumberOption: false,
  comparators: legalComparators,
  placeholder: undefined,
  style: undefined,
  className: '',
  comparatorStyle: undefined,
  comparatorClassName: '',
  numberStyle: undefined,
  numberClassName: '',
  id: null
};

exports.default = NumberFilter;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _comparison = __webpack_require__(0);

var Comparator = _interopRequireWildcard(_comparison);

var _const = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint jsx-a11y/no-static-element-interactions: 0 */
/* eslint no-return-assign: 0 */
/* eslint prefer-template: 0 */


var legalComparators = [Comparator.EQ, Comparator.NE, Comparator.GT, Comparator.GE, Comparator.LT, Comparator.LE];

function dateParser(d) {
  return d.getUTCFullYear() + '-' + ('0' + (d.getUTCMonth() + 1)).slice(-2) + '-' + ('0' + d.getUTCDate()).slice(-2);
}

var DateFilter = function (_Component) {
  _inherits(DateFilter, _Component);

  function DateFilter(props) {
    _classCallCheck(this, DateFilter);

    var _this = _possibleConstructorReturn(this, (DateFilter.__proto__ || Object.getPrototypeOf(DateFilter)).call(this, props));

    _this.timeout = null;
    _this.comparators = props.comparators || legalComparators;
    _this.applyFilter = _this.applyFilter.bind(_this);
    _this.onChangeDate = _this.onChangeDate.bind(_this);
    _this.onChangeComparator = _this.onChangeComparator.bind(_this);
    return _this;
  }

  _createClass(DateFilter, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var getFilter = this.props.getFilter;

      var comparator = this.dateFilterComparator.value;
      var date = this.inputDate.value;
      if (comparator && date) {
        this.applyFilter(date, comparator, true);
      }

      // export onFilter function to allow users to access
      if (getFilter) {
        getFilter(function (filterVal) {
          var nullableFilterVal = filterVal || { date: null, comparator: null };
          _this2.dateFilterComparator.value = nullableFilterVal.comparator;
          _this2.inputDate.value = nullableFilterVal.date ? dateParser(nullableFilterVal.date) : null;

          _this2.applyFilter(nullableFilterVal.date, nullableFilterVal.comparator);
        });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.timeout) clearTimeout(this.timeout);
    }
  }, {
    key: 'onChangeDate',
    value: function onChangeDate(e) {
      var comparator = this.dateFilterComparator.value;
      var filterValue = e.target.value;
      this.applyFilter(filterValue, comparator);
    }
  }, {
    key: 'onChangeComparator',
    value: function onChangeComparator(e) {
      var value = this.inputDate.value;
      var comparator = e.target.value;
      this.applyFilter(value, comparator);
    }
  }, {
    key: 'getComparatorOptions',
    value: function getComparatorOptions() {
      var optionTags = [];
      var withoutEmptyComparatorOption = this.props.withoutEmptyComparatorOption;

      if (!withoutEmptyComparatorOption) {
        optionTags.push(_react2.default.createElement('option', { key: '-1' }));
      }
      for (var i = 0; i < this.comparators.length; i += 1) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: i, value: this.comparators[i] },
          this.comparators[i]
        ));
      }
      return optionTags;
    }
  }, {
    key: 'getDefaultComparator',
    value: function getDefaultComparator() {
      var _props = this.props,
          defaultValue = _props.defaultValue,
          filterState = _props.filterState;

      if (filterState && filterState.filterVal) {
        return filterState.filterVal.comparator;
      }
      if (defaultValue && defaultValue.comparator) {
        return defaultValue.comparator;
      }
      return '';
    }
  }, {
    key: 'getDefaultDate',
    value: function getDefaultDate() {
      // Set the appropriate format for the input type=date, i.e. "YYYY-MM-DD"
      var _props2 = this.props,
          defaultValue = _props2.defaultValue,
          filterState = _props2.filterState;

      if (filterState && filterState.filterVal && filterState.filterVal.date) {
        return dateParser(filterState.filterVal.date);
      }
      if (defaultValue && defaultValue.date) {
        return dateParser(new Date(defaultValue.date));
      }
      return '';
    }
  }, {
    key: 'applyFilter',
    value: function applyFilter(value, comparator, isInitial) {
      // if (!comparator || !value) {
      //  return;
      // }
      var _props3 = this.props,
          column = _props3.column,
          onFilter = _props3.onFilter,
          delay = _props3.delay;

      var execute = function execute() {
        // Incoming value should always be a string, and the defaultDate
        // above is implemented as an empty string, so we can just check for that.
        // instead of parsing an invalid Date. The filter function will interpret
        // null as an empty date field
        var date = value === '' ? null : new Date(value);
        onFilter(column, _const.FILTER_TYPE.DATE, isInitial)({ date: date, comparator: comparator });
      };
      if (delay) {
        this.timeout = setTimeout(function () {
          execute();
        }, delay);
      } else {
        execute();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props4 = this.props,
          id = _props4.id,
          placeholder = _props4.placeholder,
          _props4$column = _props4.column,
          dataField = _props4$column.dataField,
          text = _props4$column.text,
          style = _props4.style,
          comparatorStyle = _props4.comparatorStyle,
          dateStyle = _props4.dateStyle,
          className = _props4.className,
          comparatorClassName = _props4.comparatorClassName,
          dateClassName = _props4.dateClassName;


      var comparatorElmId = 'date-filter-comparator-' + dataField + (id ? '-' + id : '');
      var inputElmId = 'date-filter-column-' + dataField + (id ? '-' + id : '');

      return _react2.default.createElement(
        'div',
        {
          onClick: function onClick(e) {
            return e.stopPropagation();
          },
          className: 'filter date-filter ' + className,
          style: style
        },
        _react2.default.createElement(
          'label',
          {
            className: 'filter-label',
            htmlFor: comparatorElmId
          },
          _react2.default.createElement(
            'span',
            { className: 'sr-only' },
            'Filter comparator'
          ),
          _react2.default.createElement(
            'select',
            {
              ref: function ref(n) {
                return _this3.dateFilterComparator = n;
              },
              id: comparatorElmId,
              style: comparatorStyle,
              className: 'date-filter-comparator form-control ' + comparatorClassName,
              onChange: this.onChangeComparator,
              defaultValue: this.getDefaultComparator()
            },
            this.getComparatorOptions()
          )
        ),
        _react2.default.createElement(
          'label',
          { htmlFor: inputElmId },
          _react2.default.createElement(
            'span',
            { className: 'sr-only' },
            'Enter $',
            text
          ),
          _react2.default.createElement('input', {
            ref: function ref(n) {
              return _this3.inputDate = n;
            },
            id: inputElmId,
            className: 'filter date-filter-input form-control ' + dateClassName,
            style: dateStyle,
            type: 'date',
            onChange: this.onChangeDate,
            placeholder: placeholder || 'Enter ' + text + '...',
            defaultValue: this.getDefaultDate()
          })
        )
      );
    }
  }]);

  return DateFilter;
}(_react.Component);

DateFilter.propTypes = {
  onFilter: _propTypes.PropTypes.func.isRequired,
  column: _propTypes.PropTypes.object.isRequired,
  id: _propTypes.PropTypes.string,
  filterState: _propTypes.PropTypes.object,
  delay: _propTypes.PropTypes.number,
  defaultValue: _propTypes.PropTypes.shape({
    date: _propTypes.PropTypes.oneOfType([_propTypes.PropTypes.object]),
    comparator: _propTypes.PropTypes.oneOf([].concat(legalComparators, ['']))
  }),
  /* eslint consistent-return: 0 */
  comparators: function comparators(props, propName) {
    if (!props[propName]) {
      return;
    }
    for (var i = 0; i < props[propName].length; i += 1) {
      var comparatorIsValid = false;
      for (var j = 0; j < legalComparators.length; j += 1) {
        if (legalComparators[j] === props[propName][i] || props[propName][i] === '') {
          comparatorIsValid = true;
          break;
        }
      }
      if (!comparatorIsValid) {
        return new Error('Date comparator provided is not supported.\n          Use only ' + legalComparators);
      }
    }
  },
  placeholder: _propTypes.PropTypes.string,
  withoutEmptyComparatorOption: _propTypes.PropTypes.bool,
  style: _propTypes.PropTypes.object,
  comparatorStyle: _propTypes.PropTypes.object,
  dateStyle: _propTypes.PropTypes.object,
  className: _propTypes.PropTypes.string,
  comparatorClassName: _propTypes.PropTypes.string,
  dateClassName: _propTypes.PropTypes.string,
  getFilter: _propTypes.PropTypes.func
};

DateFilter.defaultProps = {
  delay: 0,
  defaultValue: {
    date: undefined,
    comparator: ''
  },
  filterState: {},
  withoutEmptyComparatorOption: false,
  comparators: legalComparators,
  placeholder: undefined,
  style: undefined,
  className: '',
  comparatorStyle: undefined,
  comparatorClassName: '',
  dateStyle: undefined,
  dateClassName: '',
  id: null
};

exports.default = DateFilter;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _filter = __webpack_require__(15);

var _comparison = __webpack_require__(0);

var _const = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */
/* eslint react/require-default-props: 0 */
/* eslint camelcase: 0 */


exports.default = function (_, isRemoteFiltering, handleFilterChange) {
  var FilterContext = _react2.default.createContext();

  var FilterProvider = function (_React$Component) {
    _inherits(FilterProvider, _React$Component);

    function FilterProvider(props) {
      _classCallCheck(this, FilterProvider);

      var _this = _possibleConstructorReturn(this, (FilterProvider.__proto__ || Object.getPrototypeOf(FilterProvider)).call(this, props));

      _this.currFilters = {};
      _this.clearFilters = {};
      _this.onFilter = _this.onFilter.bind(_this);
      _this.doFilter = _this.doFilter.bind(_this);
      _this.onExternalFilter = _this.onExternalFilter.bind(_this);
      _this.data = props.data;
      _this.isEmitDataChange = false;
      return _this;
    }

    _createClass(FilterProvider, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (isRemoteFiltering() && Object.keys(this.currFilters).length > 0) {
          handleFilterChange(this.currFilters);
        }
      }
    }, {
      key: 'onFilter',
      value: function onFilter(column, filterType) {
        var _this2 = this;

        var initialize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        return function (filterVal) {
          // watch out here if migration to context API, #334
          var currFilters = Object.assign({}, _this2.currFilters);
          _this2.clearFilters = {};
          var dataField = column.dataField,
              filter = column.filter;


          var needClearFilters = !_.isDefined(filterVal) || filterVal === '' || filterVal.length === 0;

          if (needClearFilters) {
            delete currFilters[dataField];
            _this2.clearFilters = _defineProperty({}, dataField, { clear: true, filterVal: filterVal });
          } else {
            // select default comparator is EQ, others are LIKE
            var _filter$props = filter.props,
                _filter$props$compara = _filter$props.comparator,
                comparator = _filter$props$compara === undefined ? filterType === _const.FILTER_TYPE.SELECT ? _comparison.EQ : _comparison.LIKE : _filter$props$compara,
                _filter$props$caseSen = _filter$props.caseSensitive,
                caseSensitive = _filter$props$caseSen === undefined ? false : _filter$props$caseSen;

            currFilters[dataField] = { filterVal: filterVal, filterType: filterType, comparator: comparator, caseSensitive: caseSensitive };
          }

          _this2.currFilters = currFilters;

          if (isRemoteFiltering()) {
            if (!initialize) {
              handleFilterChange(_this2.currFilters);
            }
            return;
          }
          _this2.doFilter(_this2.props);
        };
      }
    }, {
      key: 'onExternalFilter',
      value: function onExternalFilter(column, filterType) {
        var _this3 = this;

        return function (value) {
          _this3.onFilter(column, filterType)(value);
        };
      }
    }, {
      key: 'getFiltered',
      value: function getFiltered() {
        return this.data;
      }
    }, {
      key: 'UNSAFE_componentWillReceiveProps',
      value: function UNSAFE_componentWillReceiveProps(nextProps) {
        // let nextData = nextProps.data;
        if (!isRemoteFiltering() && !_.isEqual(nextProps.data, this.data)) {
          this.doFilter(nextProps, this.isEmitDataChange);
        } else {
          this.data = nextProps.data;
        }
      }
    }, {
      key: 'doFilter',
      value: function doFilter(props) {
        var ignoreEmitDataChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var dataChangeListener = props.dataChangeListener,
            data = props.data,
            columns = props.columns;

        var result = (0, _filter.filters)(data, columns, _)(this.currFilters, this.clearFilters);
        this.data = result;
        if (dataChangeListener && !ignoreEmitDataChange) {
          this.isEmitDataChange = true;
          dataChangeListener.emit('filterChanged', result.length);
        } else {
          this.isEmitDataChange = false;
          this.forceUpdate();
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(
          FilterContext.Provider,
          { value: {
              data: this.data,
              onFilter: this.onFilter,
              onExternalFilter: this.onExternalFilter,
              currFilters: this.currFilters
            }
          },
          this.props.children
        );
      }
    }]);

    return FilterProvider;
  }(_react2.default.Component);

  FilterProvider.propTypes = {
    data: _propTypes2.default.array.isRequired,
    columns: _propTypes2.default.array.isRequired,
    dataChangeListener: _propTypes2.default.object
  };


  return {
    Provider: FilterProvider,
    Consumer: FilterContext.Consumer
  };
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filters = exports.filterFactory = exports.filterByArray = exports.filterByDate = exports.filterByNumber = exports.filterByText = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* eslint eqeqeq: 0 */
/* eslint no-console: 0 */


var _const = __webpack_require__(1);

var _comparison = __webpack_require__(0);

var filterByText = exports.filterByText = function filterByText(_) {
  return function (data, dataField, _ref, customFilterValue) {
    var _ref$filterVal = _ref.filterVal,
        userInput = _ref$filterVal === undefined ? '' : _ref$filterVal,
        _ref$comparator = _ref.comparator,
        comparator = _ref$comparator === undefined ? _comparison.LIKE : _ref$comparator,
        caseSensitive = _ref.caseSensitive;

    // make sure filter value to be a string
    var filterVal = userInput.toString();

    return data.filter(function (row) {
      var cell = _.get(row, dataField);
      if (customFilterValue) {
        cell = customFilterValue(cell, row);
      }
      var cellStr = _.isDefined(cell) ? cell.toString() : '';
      if (comparator === _comparison.EQ) {
        return cellStr === filterVal;
      }
      if (caseSensitive) {
        return cellStr.includes(filterVal);
      }

      return cellStr.toLocaleUpperCase().indexOf(filterVal.toLocaleUpperCase()) !== -1;
    });
  };
};

var filterByNumber = exports.filterByNumber = function filterByNumber(_) {
  return function (data, dataField, _ref2, customFilterValue) {
    var _ref2$filterVal = _ref2.filterVal,
        comparator = _ref2$filterVal.comparator,
        number = _ref2$filterVal.number;
    return data.filter(function (row) {
      if (number === '' || !comparator) return true;
      var valid = true;
      var cell = _.get(row, dataField);
      if (customFilterValue) {
        cell = customFilterValue(cell, row);
      }

      switch (comparator) {
        case _comparison.EQ:
          {
            if (cell != number) {
              valid = false;
            }
            break;
          }
        case _comparison.GT:
          {
            if (cell <= number) {
              valid = false;
            }
            break;
          }
        case _comparison.GE:
          {
            if (cell < number) {
              valid = false;
            }
            break;
          }
        case _comparison.LT:
          {
            if (cell >= number) {
              valid = false;
            }
            break;
          }
        case _comparison.LE:
          {
            if (cell > number) {
              valid = false;
            }
            break;
          }
        case _comparison.NE:
          {
            if (cell == number) {
              valid = false;
            }
            break;
          }
        default:
          {
            console.error('Number comparator provided is not supported');
            break;
          }
      }
      return valid;
    });
  };
};

var filterByDate = exports.filterByDate = function filterByDate(_) {
  return function (data, dataField, _ref3, customFilterValue) {
    var _ref3$filterVal = _ref3.filterVal,
        comparator = _ref3$filterVal.comparator,
        date = _ref3$filterVal.date;

    if (!date || !comparator) return data;
    var filterDate = date.getUTCDate();
    var filterMonth = date.getUTCMonth();
    var filterYear = date.getUTCFullYear();

    return data.filter(function (row) {
      var valid = true;
      var cell = _.get(row, dataField);

      if (customFilterValue) {
        cell = customFilterValue(cell, row);
      }

      if ((typeof cell === 'undefined' ? 'undefined' : _typeof(cell)) !== 'object') {
        cell = new Date(cell);
      }

      var targetDate = cell.getUTCDate();
      var targetMonth = cell.getUTCMonth();
      var targetYear = cell.getUTCFullYear();

      switch (comparator) {
        case _comparison.EQ:
          {
            if (filterDate !== targetDate || filterMonth !== targetMonth || filterYear !== targetYear) {
              valid = false;
            }
            break;
          }
        case _comparison.GT:
          {
            if (cell <= date) {
              valid = false;
            }
            break;
          }
        case _comparison.GE:
          {
            if (targetYear < filterYear) {
              valid = false;
            } else if (targetYear === filterYear && targetMonth < filterMonth) {
              valid = false;
            } else if (targetYear === filterYear && targetMonth === filterMonth && targetDate < filterDate) {
              valid = false;
            }
            break;
          }
        case _comparison.LT:
          {
            if (cell >= date) {
              valid = false;
            }
            break;
          }
        case _comparison.LE:
          {
            if (targetYear > filterYear) {
              valid = false;
            } else if (targetYear === filterYear && targetMonth > filterMonth) {
              valid = false;
            } else if (targetYear === filterYear && targetMonth === filterMonth && targetDate > filterDate) {
              valid = false;
            }
            break;
          }
        case _comparison.NE:
          {
            if (filterDate === targetDate && filterMonth === targetMonth && filterYear === targetYear) {
              valid = false;
            }
            break;
          }
        default:
          {
            console.error('Date comparator provided is not supported');
            break;
          }
      }
      return valid;
    });
  };
};

var filterByArray = exports.filterByArray = function filterByArray(_) {
  return function (data, dataField, _ref4) {
    var filterVal = _ref4.filterVal,
        comparator = _ref4.comparator;

    if (filterVal.length === 0) return data;
    var refinedFilterVal = filterVal.filter(function (x) {
      return _.isDefined(x);
    }).map(function (x) {
      return x.toString();
    });
    return data.filter(function (row) {
      var cell = _.get(row, dataField);
      var cellStr = _.isDefined(cell) ? cell.toString() : '';
      if (comparator === _comparison.EQ) {
        return refinedFilterVal.indexOf(cellStr) !== -1;
      }
      cellStr = cellStr.toLocaleUpperCase();
      return refinedFilterVal.some(function (item) {
        return cellStr.indexOf(item.toLocaleUpperCase()) !== -1;
      });
    });
  };
};

var filterFactory = exports.filterFactory = function filterFactory(_) {
  return function (filterType) {
    var filterFn = void 0;
    switch (filterType) {
      case _const.FILTER_TYPE.TEXT:
      case _const.FILTER_TYPE.SELECT:
        filterFn = filterByText(_);
        break;
      case _const.FILTER_TYPE.MULTISELECT:
        filterFn = filterByArray(_);
        break;
      case _const.FILTER_TYPE.NUMBER:
        filterFn = filterByNumber(_);
        break;
      case _const.FILTER_TYPE.DATE:
        filterFn = filterByDate(_);
        break;
      default:
        filterFn = filterByText(_);
    }
    return filterFn;
  };
};

var filters = exports.filters = function filters(data, columns, _) {
  return function (currFilters) {
    var clearFilters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var factory = filterFactory(_);
    var filterState = _extends({}, clearFilters, currFilters);
    var result = data;
    var filterFn = void 0;
    Object.keys(filterState).forEach(function (dataField) {
      var currentResult = void 0;
      var filterValue = void 0;
      var customFilter = void 0;
      for (var i = 0; i < columns.length; i += 1) {
        if (columns[i].dataField === dataField) {
          filterValue = columns[i].filterValue;
          if (columns[i].filter) {
            customFilter = columns[i].filter.props.onFilter;
          }
          break;
        }
      }

      if (clearFilters[dataField] && customFilter) {
        currentResult = customFilter(clearFilters[dataField].filterVal, result);
        if (typeof currentResult !== 'undefined') {
          result = currentResult;
        }
      } else {
        var filterObj = filterState[dataField];
        filterFn = factory(filterObj.filterType);
        if (customFilter) {
          currentResult = customFilter(filterObj.filterVal, result);
        }
        if (typeof currentResult === 'undefined') {
          result = filterFn(result, dataField, filterObj, filterValue);
        } else {
          result = currentResult;
        }
      }
    });
    return result;
  };
};

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAwOWY1NmJkYTgyMmE2NDBkMzAzYSIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcGFyaXNvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29uc3QuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJjb21tb25qc1wiOlwicmVhY3RcIixcImFtZFwiOlwicmVhY3RcIn0iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvc3JjL2NvbXBvbmVudHMvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvc3JjL2NvbXBvbmVudHMvc2VsZWN0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9jb21wb25lbnRzL211bHRpc2VsZWN0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9jb21wb25lbnRzL251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcG9uZW50cy9kYXRlLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9jb250ZXh0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9maWx0ZXIuanMiXSwibmFtZXMiOlsiTElLRSIsIkVRIiwiTkUiLCJHVCIsIkdFIiwiTFQiLCJMRSIsIkZJTFRFUl9UWVBFIiwiVEVYVCIsIlNFTEVDVCIsIk1VTFRJU0VMRUNUIiwiTlVNQkVSIiwiREFURSIsIkZJTFRFUl9ERUxBWSIsIkNvbXBhcmlzb24iLCJvcHRpb25zIiwiY3JlYXRlQ29udGV4dCIsIkZJTFRFUl9UWVBFUyIsIkNvbXBhcmF0b3IiLCJ0ZXh0RmlsdGVyIiwicHJvcHMiLCJGaWx0ZXIiLCJzZWxlY3RGaWx0ZXIiLCJtdWx0aVNlbGVjdEZpbHRlciIsIm51bWJlckZpbHRlciIsImRhdGVGaWx0ZXIiLCJjdXN0b21GaWx0ZXIiLCJUZXh0RmlsdGVyIiwiZmlsdGVyIiwiYmluZCIsImhhbmRsZUNsaWNrIiwidGltZW91dCIsImdldERlZmF1bHRWYWx1ZSIsImZpbHRlclN0YXRlIiwiZmlsdGVyVmFsIiwiZGVmYXVsdFZhbHVlIiwic3RhdGUiLCJ2YWx1ZSIsIm9uRmlsdGVyIiwiZ2V0RmlsdGVyIiwiY29sdW1uIiwiaW5wdXQiLCJzZXRTdGF0ZSIsImNsZWFuVGltZXIiLCJuZXh0UHJvcHMiLCJhcHBseUZpbHRlciIsImUiLCJzdG9wUHJvcGFnYXRpb24iLCJmaWx0ZXJWYWx1ZSIsInRhcmdldCIsInNldFRpbWVvdXQiLCJkZWxheSIsImNsZWFyVGltZW91dCIsImZpbHRlclRleHQiLCJvbkNsaWNrIiwiaWQiLCJwbGFjZWhvbGRlciIsImRhdGFGaWVsZCIsInRleHQiLCJzdHlsZSIsImNsYXNzTmFtZSIsImNhc2VTZW5zaXRpdmUiLCJyZXN0IiwiZWxtSWQiLCJuIiwicHJvcFR5cGVzIiwiZnVuYyIsImlzUmVxdWlyZWQiLCJvYmplY3QiLCJzdHJpbmciLCJjb21wYXJhdG9yIiwib25lT2YiLCJudW1iZXIiLCJib29sIiwiZGVmYXVsdFByb3BzIiwib3B0aW9uc0VxdWFscyIsImN1cnJPcHRzIiwicHJldk9wdHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJpIiwibGFiZWwiLCJrZXlzIiwiT2JqZWN0IiwiZ2V0T3B0aW9uVmFsdWUiLCJrZXkiLCJyZXN1bHQiLCJtYXAiLCJTZWxlY3RGaWx0ZXIiLCJnZXRPcHRpb25zIiwiaXNTZWxlY3RlZCIsInVuZGVmaW5lZCIsInNlbGVjdElucHV0IiwicHJldlByb3BzIiwibmVlZEZpbHRlciIsIm5leHRPcHRpb25zIiwib3B0aW9uVGFncyIsIndpdGhvdXRFbXB0eU9wdGlvbiIsInB1c2giLCJmb3JFYWNoIiwic2VsZWN0Q2xhc3MiLCJyZW5kZXJPcHRpb25zIiwib25lT2ZUeXBlIiwiYXJyYXkiLCJhbnkiLCJnZXRTZWxlY3Rpb25zIiwiY29udGFpbmVyIiwic2VsZWN0ZWRPcHRpb25zIiwiZnJvbSIsIml0ZW0iLCJzZWxlY3Rpb25zIiwidG90YWxMZW4iLCJvcHRpb24iLCJzZWxlY3RlZCIsIk11bHRpU2VsZWN0RmlsdGVyIiwibGVnYWxDb21wYXJhdG9ycyIsIk51bWJlckZpbHRlciIsImNvbXBhcmF0b3JzIiwiaW5kZXhPZiIsIm9uQ2hhbmdlTnVtYmVyIiwib25DaGFuZ2VOdW1iZXJTZXQiLCJvbkNoYW5nZUNvbXBhcmF0b3IiLCJudW1iZXJGaWx0ZXJDb21wYXJhdG9yIiwid2l0aG91dEVtcHR5Q29tcGFyYXRvck9wdGlvbiIsIndpdGhvdXRFbXB0eU51bWJlck9wdGlvbiIsImZpbHRlck9iaiIsIm51bWJlclN0eWxlIiwibnVtYmVyQ2xhc3NOYW1lIiwiY29tcGFyYXRvclN0eWxlIiwiY29tcGFyYXRvckNsYXNzTmFtZSIsImNvbXBhcmF0b3JFbG1JZCIsImlucHV0RWxtSWQiLCJnZXREZWZhdWx0Q29tcGFyYXRvciIsImdldENvbXBhcmF0b3JPcHRpb25zIiwiZ2V0TnVtYmVyT3B0aW9ucyIsImFycmF5T2YiLCJzaGFwZSIsInByb3BOYW1lIiwiY29tcGFyYXRvcklzVmFsaWQiLCJqIiwiRXJyb3IiLCJkYXRlUGFyc2VyIiwiZCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJzbGljZSIsImdldFVUQ0RhdGUiLCJEYXRlRmlsdGVyIiwib25DaGFuZ2VEYXRlIiwiZGF0ZUZpbHRlckNvbXBhcmF0b3IiLCJkYXRlIiwiaW5wdXREYXRlIiwibnVsbGFibGVGaWx0ZXJWYWwiLCJEYXRlIiwiaXNJbml0aWFsIiwiZXhlY3V0ZSIsImRhdGVTdHlsZSIsImRhdGVDbGFzc05hbWUiLCJnZXREZWZhdWx0RGF0ZSIsIl8iLCJpc1JlbW90ZUZpbHRlcmluZyIsImhhbmRsZUZpbHRlckNoYW5nZSIsIkZpbHRlckNvbnRleHQiLCJGaWx0ZXJQcm92aWRlciIsImN1cnJGaWx0ZXJzIiwiY2xlYXJGaWx0ZXJzIiwiZG9GaWx0ZXIiLCJvbkV4dGVybmFsRmlsdGVyIiwiZGF0YSIsImlzRW1pdERhdGFDaGFuZ2UiLCJmaWx0ZXJUeXBlIiwiaW5pdGlhbGl6ZSIsImFzc2lnbiIsIm5lZWRDbGVhckZpbHRlcnMiLCJpc0RlZmluZWQiLCJjbGVhciIsImlzRXF1YWwiLCJpZ25vcmVFbWl0RGF0YUNoYW5nZSIsImRhdGFDaGFuZ2VMaXN0ZW5lciIsImNvbHVtbnMiLCJlbWl0IiwiZm9yY2VVcGRhdGUiLCJjaGlsZHJlbiIsIkNvbXBvbmVudCIsIlByb3ZpZGVyIiwiQ29uc3VtZXIiLCJmaWx0ZXJCeVRleHQiLCJjdXN0b21GaWx0ZXJWYWx1ZSIsInVzZXJJbnB1dCIsInRvU3RyaW5nIiwicm93IiwiY2VsbCIsImdldCIsImNlbGxTdHIiLCJpbmNsdWRlcyIsInRvTG9jYWxlVXBwZXJDYXNlIiwiZmlsdGVyQnlOdW1iZXIiLCJ2YWxpZCIsImNvbnNvbGUiLCJlcnJvciIsImZpbHRlckJ5RGF0ZSIsImZpbHRlckRhdGUiLCJmaWx0ZXJNb250aCIsImZpbHRlclllYXIiLCJ0YXJnZXREYXRlIiwidGFyZ2V0TW9udGgiLCJ0YXJnZXRZZWFyIiwiZmlsdGVyQnlBcnJheSIsInJlZmluZWRGaWx0ZXJWYWwiLCJ4Iiwic29tZSIsImZpbHRlckZhY3RvcnkiLCJmaWx0ZXJGbiIsImZpbHRlcnMiLCJmYWN0b3J5IiwiY3VycmVudFJlc3VsdCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdETyxJQUFNQSxzQkFBTyxNQUFiO0FBQ0EsSUFBTUMsa0JBQUssR0FBWDtBQUNBLElBQU1DLGtCQUFLLElBQVg7QUFDQSxJQUFNQyxrQkFBSyxHQUFYO0FBQ0EsSUFBTUMsa0JBQUssSUFBWDtBQUNBLElBQU1DLGtCQUFLLEdBQVg7QUFDQSxJQUFNQyxrQkFBSyxJQUFYLEM7Ozs7Ozs7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QUFDRDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSWdJLGFBQWE3RyxTQUFiLEtBQTJCL0IsWUFBL0IsRUFBNkM7QUFDM0M4TCx3QkFBZ0I5TCxhQUFhNEksYUFBYTdHLFNBQWIsRUFBd0J2QixTQUFyQyxFQUFnRHFELE1BQWhELENBQWhCO0FBQ0EsWUFBSSxPQUFPaUksYUFBUCxLQUF5QixXQUE3QixFQUEwQztBQUN4Q2pJLG1CQUFTaUksYUFBVDtBQUNEO0FBQ0YsT0FMRCxNQUtPO0FBQ0wsWUFBTTFGLFlBQVk3RixZQUFZd0IsU0FBWixDQUFsQjtBQUNBNEosbUJBQVdFLFFBQVF6RixVQUFVNkMsVUFBbEIsQ0FBWDtBQUNBLFlBQUlqSixZQUFKLEVBQWtCO0FBQ2hCOEwsMEJBQWdCOUwsYUFBYW9HLFVBQVU1RixTQUF2QixFQUFrQ3FELE1BQWxDLENBQWhCO0FBQ0Q7QUFDRCxZQUFJLE9BQU9pSSxhQUFQLEtBQXlCLFdBQTdCLEVBQTBDO0FBQ3hDakksbUJBQVM4SCxTQUFTOUgsTUFBVCxFQUFpQjlCLFNBQWpCLEVBQTRCcUUsU0FBNUIsRUFBdUM5RSxXQUF2QyxDQUFUO0FBQ0QsU0FGRCxNQUVPO0FBQ0x1QyxtQkFBU2lJLGFBQVQ7QUFDRDtBQUNGO0FBQ0YsS0EvQkQ7QUFnQ0EsV0FBT2pJLE1BQVA7QUFDRCxHQXRDc0I7QUFBQSxDQUFoQixDIiwiZmlsZSI6InJlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL2Rpc3QvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJyZWFjdFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJSZWFjdEJvb3RzdHJhcFRhYmxlMkZpbHRlclwiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJSZWFjdEJvb3RzdHJhcFRhYmxlMkZpbHRlclwiXSA9IGZhY3Rvcnkocm9vdFtcIlJlYWN0XCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDA5ZjU2YmRhODIyYTY0MGQzMDNhIiwiZXhwb3J0IGNvbnN0IExJS0UgPSAnTElLRSc7XG5leHBvcnQgY29uc3QgRVEgPSAnPSc7XG5leHBvcnQgY29uc3QgTkUgPSAnIT0nO1xuZXhwb3J0IGNvbnN0IEdUID0gJz4nO1xuZXhwb3J0IGNvbnN0IEdFID0gJz49JztcbmV4cG9ydCBjb25zdCBMVCA9ICc8JztcbmV4cG9ydCBjb25zdCBMRSA9ICc8PSc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcGFyaXNvbi5qcyIsImV4cG9ydCBjb25zdCBGSUxURVJfVFlQRSA9IHtcbiAgVEVYVDogJ1RFWFQnLFxuICBTRUxFQ1Q6ICdTRUxFQ1QnLFxuICBNVUxUSVNFTEVDVDogJ01VTFRJU0VMRUNUJyxcbiAgTlVNQkVSOiAnTlVNQkVSJyxcbiAgREFURTogJ0RBVEUnXG59O1xuXG5leHBvcnQgY29uc3QgRklMVEVSX0RFTEFZID0gNTAwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvc3JjL2NvbnN0LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9XG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgVGV4dEZpbHRlciBmcm9tICcuL3NyYy9jb21wb25lbnRzL3RleHQnO1xuaW1wb3J0IFNlbGVjdEZpbHRlciBmcm9tICcuL3NyYy9jb21wb25lbnRzL3NlbGVjdCc7XG5pbXBvcnQgTXVsdGlTZWxlY3RGaWx0ZXIgZnJvbSAnLi9zcmMvY29tcG9uZW50cy9tdWx0aXNlbGVjdCc7XG5pbXBvcnQgTnVtYmVyRmlsdGVyIGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbnVtYmVyJztcbmltcG9ydCBEYXRlRmlsdGVyIGZyb20gJy4vc3JjL2NvbXBvbmVudHMvZGF0ZSc7XG5pbXBvcnQgY3JlYXRlQ29udGV4dCBmcm9tICcuL3NyYy9jb250ZXh0JztcbmltcG9ydCAqIGFzIENvbXBhcmlzb24gZnJvbSAnLi9zcmMvY29tcGFyaXNvbic7XG5pbXBvcnQgeyBGSUxURVJfVFlQRSB9IGZyb20gJy4vc3JjL2NvbnN0JztcblxuZXhwb3J0IGRlZmF1bHQgKG9wdGlvbnMgPSB7fSkgPT4gKHtcbiAgY3JlYXRlQ29udGV4dCxcbiAgb3B0aW9uc1xufSk7XG5cbmV4cG9ydCBjb25zdCBGSUxURVJfVFlQRVMgPSBGSUxURVJfVFlQRTtcblxuZXhwb3J0IGNvbnN0IENvbXBhcmF0b3IgPSBDb21wYXJpc29uO1xuXG5leHBvcnQgY29uc3QgdGV4dEZpbHRlciA9IChwcm9wcyA9IHt9KSA9PiAoe1xuICBGaWx0ZXI6IFRleHRGaWx0ZXIsXG4gIHByb3BzXG59KTtcblxuZXhwb3J0IGNvbnN0IHNlbGVjdEZpbHRlciA9IChwcm9wcyA9IHt9KSA9PiAoe1xuICBGaWx0ZXI6IFNlbGVjdEZpbHRlcixcbiAgcHJvcHNcbn0pO1xuXG5leHBvcnQgY29uc3QgbXVsdGlTZWxlY3RGaWx0ZXIgPSAocHJvcHMgPSB7fSkgPT4gKHtcbiAgRmlsdGVyOiBNdWx0aVNlbGVjdEZpbHRlcixcbiAgcHJvcHNcbn0pO1xuXG5leHBvcnQgY29uc3QgbnVtYmVyRmlsdGVyID0gKHByb3BzID0ge30pID0+ICh7XG4gIEZpbHRlcjogTnVtYmVyRmlsdGVyLFxuICBwcm9wc1xufSk7XG5cbmV4cG9ydCBjb25zdCBkYXRlRmlsdGVyID0gKHByb3BzID0ge30pID0+ICh7XG4gIEZpbHRlcjogRGF0ZUZpbHRlcixcbiAgcHJvcHNcbn0pO1xuXG5leHBvcnQgY29uc3QgY3VzdG9tRmlsdGVyID0gKHByb3BzID0ge30pID0+ICh7XG4gIHByb3BzXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL2luZGV4LmpzIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbi8qIGVzbGludCBuby1yZXR1cm4tYXNzaWduOiAwICovXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJvcFR5cGVzIH0gZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCB7IExJS0UsIEVRIH0gZnJvbSAnLi4vY29tcGFyaXNvbic7XG5pbXBvcnQgeyBGSUxURVJfVFlQRSwgRklMVEVSX0RFTEFZIH0gZnJvbSAnLi4vY29uc3QnO1xuXG5jbGFzcyBUZXh0RmlsdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5maWx0ZXIgPSB0aGlzLmZpbHRlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICBmdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUoKSB7XG4gICAgICBpZiAocHJvcHMuZmlsdGVyU3RhdGUgJiYgdHlwZW9mIHByb3BzLmZpbHRlclN0YXRlLmZpbHRlclZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzLmZpbHRlclN0YXRlLmZpbHRlclZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB2YWx1ZTogZ2V0RGVmYXVsdFZhbHVlKClcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBvbkZpbHRlciwgZ2V0RmlsdGVyLCBjb2x1bW4gfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5pbnB1dC52YWx1ZTtcblxuICAgIGlmIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgIG9uRmlsdGVyKHRoaXMucHJvcHMuY29sdW1uLCBGSUxURVJfVFlQRS5URVhULCB0cnVlKShkZWZhdWx0VmFsdWUpO1xuICAgIH1cblxuICAgIC8vIGV4cG9ydCBvbkZpbHRlciBmdW5jdGlvbiB0byBhbGxvdyB1c2VycyB0byBhY2Nlc3NcbiAgICBpZiAoZ2V0RmlsdGVyKSB7XG4gICAgICBnZXRGaWx0ZXIoKGZpbHRlclZhbCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IHZhbHVlOiBmaWx0ZXJWYWwgfSkpO1xuICAgICAgICBvbkZpbHRlcihjb2x1bW4sIEZJTFRFUl9UWVBFLlRFWFQpKGZpbHRlclZhbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNsZWFuVGltZXIoKTtcbiAgfVxuXG4gIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuZGVmYXVsdFZhbHVlICE9PSB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgdGhpcy5hcHBseUZpbHRlcihuZXh0UHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmaWx0ZXIoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5jbGVhblRpbWVyKCk7XG4gICAgY29uc3QgZmlsdGVyVmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IHZhbHVlOiBmaWx0ZXJWYWx1ZSB9KSk7XG4gICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnByb3BzLm9uRmlsdGVyKHRoaXMucHJvcHMuY29sdW1uLCBGSUxURVJfVFlQRS5URVhUKShmaWx0ZXJWYWx1ZSk7XG4gICAgfSwgdGhpcy5wcm9wcy5kZWxheSk7XG4gIH1cblxuICBjbGVhblRpbWVyKCkge1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFuRmlsdGVyZWQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IHZhbHVlIH0pKTtcbiAgICB0aGlzLnByb3BzLm9uRmlsdGVyKHRoaXMucHJvcHMuY29sdW1uLCBGSUxURVJfVFlQRS5URVhUKSh2YWx1ZSk7XG4gIH1cblxuICBhcHBseUZpbHRlcihmaWx0ZXJUZXh0KSB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyB2YWx1ZTogZmlsdGVyVGV4dCB9KSk7XG4gICAgdGhpcy5wcm9wcy5vbkZpbHRlcih0aGlzLnByb3BzLmNvbHVtbiwgRklMVEVSX1RZUEUuVEVYVCkoZmlsdGVyVGV4dCk7XG4gIH1cblxuICBoYW5kbGVDbGljayhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2soZSk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBjb2x1bW46IHsgZGF0YUZpZWxkLCB0ZXh0IH0sXG4gICAgICBzdHlsZSxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIG9uRmlsdGVyLFxuICAgICAgY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgIGdldEZpbHRlcixcbiAgICAgIGZpbHRlclN0YXRlLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgZWxtSWQgPSBgdGV4dC1maWx0ZXItY29sdW1uLSR7ZGF0YUZpZWxkfSR7aWQgPyBgLSR7aWR9YCA6ICcnfWA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGxhYmVsXG4gICAgICAgIGNsYXNzTmFtZT1cImZpbHRlci1sYWJlbFwiXG4gICAgICAgIGh0bWxGb3I9eyBlbG1JZCB9XG4gICAgICA+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNyLW9ubHlcIj5GaWx0ZXIgYnkge3RleHR9PC9zcGFuPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB7IC4uLnJlc3QgfVxuICAgICAgICAgIHJlZj17IG4gPT4gdGhpcy5pbnB1dCA9IG4gfVxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBpZD17IGVsbUlkIH1cbiAgICAgICAgICBjbGFzc05hbWU9eyBgZmlsdGVyIHRleHQtZmlsdGVyIGZvcm0tY29udHJvbCAke2NsYXNzTmFtZX1gIH1cbiAgICAgICAgICBzdHlsZT17IHN0eWxlIH1cbiAgICAgICAgICBvbkNoYW5nZT17IHRoaXMuZmlsdGVyIH1cbiAgICAgICAgICBvbkNsaWNrPXsgdGhpcy5oYW5kbGVDbGljayB9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9eyBwbGFjZWhvbGRlciB8fCBgRW50ZXIgJHt0ZXh0fS4uLmAgfVxuICAgICAgICAgIHZhbHVlPXsgdGhpcy5zdGF0ZS52YWx1ZSB9XG4gICAgICAgIC8+XG4gICAgICA8L2xhYmVsPlxuICAgICk7XG4gIH1cbn1cblxuVGV4dEZpbHRlci5wcm9wVHlwZXMgPSB7XG4gIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBjb2x1bW46IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZpbHRlclN0YXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjb21wYXJhdG9yOiBQcm9wVHlwZXMub25lT2YoW0xJS0UsIEVRXSksXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZGVsYXk6IFByb3BUeXBlcy5udW1iZXIsXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjYXNlU2Vuc2l0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ2V0RmlsdGVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuVGV4dEZpbHRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGRlbGF5OiBGSUxURVJfREVMQVksXG4gIGZpbHRlclN0YXRlOiB7fSxcbiAgZGVmYXVsdFZhbHVlOiAnJyxcbiAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gIGlkOiBudWxsXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFRleHRGaWx0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcG9uZW50cy90ZXh0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuLyogZXNsaW50IG5vLXJldHVybi1hc3NpZ246IDAgKi9cbi8qIGVzbGludCByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlczogMCAqL1xuLyogZXNsaW50IGNsYXNzLW1ldGhvZHMtdXNlLXRoaXM6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgTElLRSwgRVEgfSBmcm9tICcuLi9jb21wYXJpc29uJztcbmltcG9ydCB7IEZJTFRFUl9UWVBFIH0gZnJvbSAnLi4vY29uc3QnO1xuXG5mdW5jdGlvbiBvcHRpb25zRXF1YWxzKGN1cnJPcHRzLCBwcmV2T3B0cykge1xuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyT3B0cykpIHtcbiAgICBpZiAoY3Vyck9wdHMubGVuZ3RoID09PSBwcmV2T3B0cy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3Vyck9wdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1cnJPcHRzW2ldLnZhbHVlICE9PSBwcmV2T3B0c1tpXS52YWx1ZSB8fFxuICAgICAgICAgIGN1cnJPcHRzW2ldLmxhYmVsICE9PSBwcmV2T3B0c1tpXS5sYWJlbFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cnJPcHRzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGN1cnJPcHRzW2tleXNbaV1dICE9PSBwcmV2T3B0c1trZXlzW2ldXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMoY3Vyck9wdHMpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMocHJldk9wdHMpLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gZ2V0T3B0aW9uVmFsdWUob3B0aW9ucywga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uc1xuICAgICAgLmZpbHRlcigoeyBsYWJlbCB9KSA9PiBsYWJlbCA9PT0ga2V5KVxuICAgICAgLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1trZXldO1xufVxuXG5jbGFzcyBTZWxlY3RGaWx0ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLmZpbHRlciA9IHRoaXMuZmlsdGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKHByb3BzKTtcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gZ2V0T3B0aW9uVmFsdWUodGhpcy5vcHRpb25zLCB0aGlzLmdldERlZmF1bHRWYWx1ZSgpKSAhPT0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhdGUgPSB7IGlzU2VsZWN0ZWQgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgY29sdW1uLCBvbkZpbHRlciwgZ2V0RmlsdGVyIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnNlbGVjdElucHV0LnZhbHVlO1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgIG9uRmlsdGVyKGNvbHVtbiwgRklMVEVSX1RZUEUuU0VMRUNULCB0cnVlKSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0IG9uRmlsdGVyIGZ1bmN0aW9uIHRvIGFsbG93IHVzZXJzIHRvIGFjY2Vzc1xuICAgIGlmIChnZXRGaWx0ZXIpIHtcbiAgICAgIGdldEZpbHRlcigoZmlsdGVyVmFsKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgaXNTZWxlY3RlZDogZmlsdGVyVmFsICE9PSAnJyB9KSk7XG4gICAgICAgIHRoaXMuc2VsZWN0SW5wdXQudmFsdWUgPSBmaWx0ZXJWYWw7XG5cbiAgICAgICAgb25GaWx0ZXIoY29sdW1uLCBGSUxURVJfVFlQRS5TRUxFQ1QpKGZpbHRlclZhbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgbGV0IG5lZWRGaWx0ZXIgPSBmYWxzZTtcbiAgICBjb25zdCB7XG4gICAgICBjb2x1bW4sXG4gICAgICBvbkZpbHRlcixcbiAgICAgIGRlZmF1bHRWYWx1ZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG5leHRPcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKHRoaXMucHJvcHMpO1xuICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IHByZXZQcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgIG5lZWRGaWx0ZXIgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnNFcXVhbHMobmV4dE9wdGlvbnMsIHRoaXMub3B0aW9ucykpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG5leHRPcHRpb25zO1xuICAgICAgbmVlZEZpbHRlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChuZWVkRmlsdGVyKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc2VsZWN0SW5wdXQudmFsdWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgb25GaWx0ZXIoY29sdW1uLCBGSUxURVJfVFlQRS5TRUxFQ1QpKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRPcHRpb25zKHByb3BzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5vcHRpb25zID09PSAnZnVuY3Rpb24nID8gcHJvcHMub3B0aW9ucyhwcm9wcy5jb2x1bW4pIDogcHJvcHMub3B0aW9ucztcbiAgfVxuXG4gIGdldERlZmF1bHRWYWx1ZSgpIHtcbiAgICBjb25zdCB7IGZpbHRlclN0YXRlLCBkZWZhdWx0VmFsdWUgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGZpbHRlclN0YXRlICYmIHR5cGVvZiBmaWx0ZXJTdGF0ZS5maWx0ZXJWYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmlsdGVyU3RhdGUuZmlsdGVyVmFsO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgY2xlYW5GaWx0ZXJlZCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSA/IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlIDogJyc7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBpc1NlbGVjdGVkOiB2YWx1ZSAhPT0gJycgfSkpO1xuICAgIHRoaXMuc2VsZWN0SW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnByb3BzLm9uRmlsdGVyKHRoaXMucHJvcHMuY29sdW1uLCBGSUxURVJfVFlQRS5TRUxFQ1QpKHZhbHVlKTtcbiAgfVxuXG4gIGFwcGx5RmlsdGVyKHZhbHVlKSB7XG4gICAgdGhpcy5zZWxlY3RJbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgaXNTZWxlY3RlZDogdmFsdWUgIT09ICcnIH0pKTtcbiAgICB0aGlzLnByb3BzLm9uRmlsdGVyKHRoaXMucHJvcHMuY29sdW1uLCBGSUxURVJfVFlQRS5TRUxFQ1QpKHZhbHVlKTtcbiAgfVxuXG4gIGZpbHRlcihlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gZS50YXJnZXQ7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBpc1NlbGVjdGVkOiB2YWx1ZSAhPT0gJycgfSkpO1xuICAgIHRoaXMucHJvcHMub25GaWx0ZXIodGhpcy5wcm9wcy5jb2x1bW4sIEZJTFRFUl9UWVBFLlNFTEVDVCkodmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyT3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25UYWdzID0gW107XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcGxhY2Vob2xkZXIsIGNvbHVtbiwgd2l0aG91dEVtcHR5T3B0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghd2l0aG91dEVtcHR5T3B0aW9uKSB7XG4gICAgICBvcHRpb25UYWdzLnB1c2goKFxuICAgICAgICA8b3B0aW9uIGtleT1cIi0xXCIgdmFsdWU9XCJcIj57IHBsYWNlaG9sZGVyIHx8IGBTZWxlY3QgJHtjb2x1bW4udGV4dH0uLi5gIH08L29wdGlvbj5cbiAgICAgICkpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5mb3JFYWNoKCh7IHZhbHVlLCBsYWJlbCB9KSA9PlxuICAgICAgICBvcHRpb25UYWdzLnB1c2goPG9wdGlvbiBrZXk9eyB2YWx1ZSB9IHZhbHVlPXsgdmFsdWUgfT57IGxhYmVsIH08L29wdGlvbj4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChrZXkgPT5cbiAgICAgICAgb3B0aW9uVGFncy5wdXNoKDxvcHRpb24ga2V5PXsga2V5IH0gdmFsdWU9eyBrZXkgfT57IG9wdGlvbnNba2V5XSB9PC9vcHRpb24+KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvblRhZ3M7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBzdHlsZSxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgIG9uRmlsdGVyLFxuICAgICAgY29sdW1uLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNvbXBhcmF0b3IsXG4gICAgICB3aXRob3V0RW1wdHlPcHRpb24sXG4gICAgICBjYXNlU2Vuc2l0aXZlLFxuICAgICAgZ2V0RmlsdGVyLFxuICAgICAgZmlsdGVyU3RhdGUsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBzZWxlY3RDbGFzcyA9XG4gICAgICBgZmlsdGVyIHNlbGVjdC1maWx0ZXIgZm9ybS1jb250cm9sICR7Y2xhc3NOYW1lfSAke3RoaXMuc3RhdGUuaXNTZWxlY3RlZCA/ICcnIDogJ3BsYWNlaG9sZGVyLXNlbGVjdGVkJ31gO1xuICAgIGNvbnN0IGVsbUlkID0gYHNlbGVjdC1maWx0ZXItY29sdW1uLSR7Y29sdW1uLmRhdGFGaWVsZH0ke2lkID8gYC0ke2lkfWAgOiAnJ31gO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxsYWJlbFxuICAgICAgICBjbGFzc05hbWU9XCJmaWx0ZXItbGFiZWxcIlxuICAgICAgICBodG1sRm9yPXsgZWxtSWQgfVxuICAgICAgPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzci1vbmx5XCI+RmlsdGVyIGJ5IHsgY29sdW1uLnRleHQgfTwvc3Bhbj5cbiAgICAgICAgPHNlbGVjdFxuICAgICAgICAgIHsgLi4ucmVzdCB9XG4gICAgICAgICAgcmVmPXsgbiA9PiB0aGlzLnNlbGVjdElucHV0ID0gbiB9XG4gICAgICAgICAgaWQ9eyBlbG1JZCB9XG4gICAgICAgICAgc3R5bGU9eyBzdHlsZSB9XG4gICAgICAgICAgY2xhc3NOYW1lPXsgc2VsZWN0Q2xhc3MgfVxuICAgICAgICAgIG9uQ2hhbmdlPXsgdGhpcy5maWx0ZXIgfVxuICAgICAgICAgIG9uQ2xpY2s9eyBlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCkgfVxuICAgICAgICAgIGRlZmF1bHRWYWx1ZT17IHRoaXMuZ2V0RGVmYXVsdFZhbHVlKCkgfHwgJycgfVxuICAgICAgICA+XG4gICAgICAgICAgeyB0aGlzLnJlbmRlck9wdGlvbnMoKSB9XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgPC9sYWJlbD5cbiAgICApO1xuICB9XG59XG5cblNlbGVjdEZpbHRlci5wcm9wVHlwZXMgPSB7XG4gIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBjb2x1bW46IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZpbHRlclN0YXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBvcHRpb25zOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuYXJyYXldKS5pc1JlcXVpcmVkLFxuICBjb21wYXJhdG9yOiBQcm9wVHlwZXMub25lT2YoW0xJS0UsIEVRXSksXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB3aXRob3V0RW1wdHlPcHRpb246IFByb3BUeXBlcy5ib29sLFxuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hbnksXG4gIGNhc2VTZW5zaXRpdmU6IFByb3BUeXBlcy5ib29sLFxuICBnZXRGaWx0ZXI6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5TZWxlY3RGaWx0ZXIuZGVmYXVsdFByb3BzID0ge1xuICBkZWZhdWx0VmFsdWU6ICcnLFxuICBmaWx0ZXJTdGF0ZToge30sXG4gIGNsYXNzTmFtZTogJycsXG4gIHdpdGhvdXRFbXB0eU9wdGlvbjogZmFsc2UsXG4gIGNvbXBhcmF0b3I6IEVRLFxuICBjYXNlU2Vuc2l0aXZlOiB0cnVlLFxuICBpZDogbnVsbFxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0RmlsdGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvc3JjL2NvbXBvbmVudHMvc2VsZWN0LmpzIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuLyogZXNsaW50IG5vLXJldHVybi1hc3NpZ246IDAgKi9cbi8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogMCAqL1xuLyogZXNsaW50IHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IExJS0UsIEVRIH0gZnJvbSAnLi4vY29tcGFyaXNvbic7XG5pbXBvcnQgeyBGSUxURVJfVFlQRSB9IGZyb20gJy4uL2NvbnN0JztcblxuXG5mdW5jdGlvbiBvcHRpb25zRXF1YWxzKGN1cnJPcHRzLCBwcmV2T3B0cykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY3Vyck9wdHMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoY3Vyck9wdHNba2V5c1tpXV0gIT09IHByZXZPcHRzW2tleXNbaV1dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhjdXJyT3B0cykubGVuZ3RoID09PSBPYmplY3Qua2V5cyhwcmV2T3B0cykubGVuZ3RoO1xufVxuXG5jb25zdCBnZXRTZWxlY3Rpb25zID0gKGNvbnRhaW5lcikgPT4ge1xuICBpZiAoY29udGFpbmVyLnNlbGVjdGVkT3B0aW9ucykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGNvbnRhaW5lci5zZWxlY3RlZE9wdGlvbnMpLm1hcChpdGVtID0+IGl0ZW0udmFsdWUpO1xuICB9XG4gIGNvbnN0IHNlbGVjdGlvbnMgPSBbXTtcbiAgY29uc3QgdG90YWxMZW4gPSBjb250YWluZXIub3B0aW9ucy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxMZW47IGkgKz0gMSkge1xuICAgIGNvbnN0IG9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zLml0ZW0oaSk7XG4gICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkgc2VsZWN0aW9ucy5wdXNoKG9wdGlvbi52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGlvbnM7XG59O1xuXG5jbGFzcyBNdWx0aVNlbGVjdEZpbHRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuZmlsdGVyID0gdGhpcy5maWx0ZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFwcGx5RmlsdGVyID0gdGhpcy5hcHBseUZpbHRlci5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBwcm9wcy5kZWZhdWx0VmFsdWUubWFwKGl0ZW0gPT4gcHJvcHMub3B0aW9uc1tpdGVtXSkubGVuZ3RoID4gMDtcbiAgICB0aGlzLnN0YXRlID0geyBpc1NlbGVjdGVkIH07XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGdldEZpbHRlciB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHZhbHVlID0gZ2V0U2VsZWN0aW9ucyh0aGlzLnNlbGVjdElucHV0KTtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hcHBseUZpbHRlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0IG9uRmlsdGVyIGZ1bmN0aW9uIHRvIGFsbG93IHVzZXJzIHRvIGFjY2Vzc1xuICAgIGlmIChnZXRGaWx0ZXIpIHtcbiAgICAgIGdldEZpbHRlcigoZmlsdGVyVmFsKSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0SW5wdXQudmFsdWUgPSBmaWx0ZXJWYWw7XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoZmlsdGVyVmFsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBsZXQgbmVlZEZpbHRlciA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gcHJldlByb3BzLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgbmVlZEZpbHRlciA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghb3B0aW9uc0VxdWFscyh0aGlzLnByb3BzLm9wdGlvbnMsIHByZXZQcm9wcy5vcHRpb25zKSkge1xuICAgICAgbmVlZEZpbHRlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChuZWVkRmlsdGVyKSB7XG4gICAgICB0aGlzLmFwcGx5RmlsdGVyKGdldFNlbGVjdGlvbnModGhpcy5zZWxlY3RJbnB1dCkpO1xuICAgIH1cbiAgfVxuXG4gIGdldERlZmF1bHRWYWx1ZSgpIHtcbiAgICBjb25zdCB7IGZpbHRlclN0YXRlLCBkZWZhdWx0VmFsdWUgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGZpbHRlclN0YXRlICYmIHR5cGVvZiBmaWx0ZXJTdGF0ZS5maWx0ZXJWYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmlsdGVyU3RhdGUuZmlsdGVyVmFsO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25UYWdzID0gW107XG4gICAgY29uc3QgeyBvcHRpb25zLCBwbGFjZWhvbGRlciwgY29sdW1uLCB3aXRob3V0RW1wdHlPcHRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCF3aXRob3V0RW1wdHlPcHRpb24pIHtcbiAgICAgIG9wdGlvblRhZ3MucHVzaCgoXG4gICAgICAgIDxvcHRpb24ga2V5PVwiLTFcIiB2YWx1ZT1cIlwiPnsgcGxhY2Vob2xkZXIgfHwgYFNlbGVjdCAke2NvbHVtbi50ZXh0fS4uLmAgfTwvb3B0aW9uPlxuICAgICAgKSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goa2V5ID0+XG4gICAgICBvcHRpb25UYWdzLnB1c2goPG9wdGlvbiBrZXk9eyBrZXkgfSB2YWx1ZT17IGtleSB9Pnsgb3B0aW9uc1trZXldIH08L29wdGlvbj4pXG4gICAgKTtcbiAgICByZXR1cm4gb3B0aW9uVGFncztcbiAgfVxuXG4gIGNsZWFuRmlsdGVyZWQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSAodGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkgPyB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSA6IFtdO1xuICAgIHRoaXMuc2VsZWN0SW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmFwcGx5RmlsdGVyKHZhbHVlKTtcbiAgfVxuXG4gIGFwcGx5RmlsdGVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZVswXSA9PT0gJycpIHtcbiAgICAgIHZhbHVlID0gW107XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgaXNTZWxlY3RlZDogdmFsdWUubGVuZ3RoID4gMCB9KSk7XG4gICAgdGhpcy5wcm9wcy5vbkZpbHRlcih0aGlzLnByb3BzLmNvbHVtbiwgRklMVEVSX1RZUEUuTVVMVElTRUxFQ1QpKHZhbHVlKTtcbiAgfVxuXG4gIGZpbHRlcihlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRTZWxlY3Rpb25zKGUudGFyZ2V0KTtcbiAgICB0aGlzLmFwcGx5RmlsdGVyKHZhbHVlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIHN0eWxlLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgZmlsdGVyU3RhdGUsXG4gICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICBvbkZpbHRlcixcbiAgICAgIGNvbHVtbixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjb21wYXJhdG9yLFxuICAgICAgd2l0aG91dEVtcHR5T3B0aW9uLFxuICAgICAgY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGdldEZpbHRlcixcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHNlbGVjdENsYXNzID1cbiAgICAgIGBmaWx0ZXIgc2VsZWN0LWZpbHRlciBmb3JtLWNvbnRyb2wgJHtjbGFzc05hbWV9ICR7dGhpcy5zdGF0ZS5pc1NlbGVjdGVkID8gJycgOiAncGxhY2Vob2xkZXItc2VsZWN0ZWQnfWA7XG4gICAgY29uc3QgZWxtSWQgPSBgbXVsdGlzZWxlY3QtZmlsdGVyLWNvbHVtbi0ke2NvbHVtbi5kYXRhRmllbGR9JHtpZCA/IGAtJHtpZH1gIDogJyd9YDtcblxuICAgIHJldHVybiAoXG4gICAgICA8bGFiZWxcbiAgICAgICAgY2xhc3NOYW1lPVwiZmlsdGVyLWxhYmVsXCJcbiAgICAgICAgaHRtbEZvcj17IGVsbUlkIH1cbiAgICAgID5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic3Itb25seVwiPkZpbHRlciBieSB7Y29sdW1uLnRleHR9PC9zcGFuPlxuICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgeyAuLi5yZXN0IH1cbiAgICAgICAgICByZWY9eyBuID0+IHRoaXMuc2VsZWN0SW5wdXQgPSBuIH1cbiAgICAgICAgICBpZD17IGVsbUlkIH1cbiAgICAgICAgICBzdHlsZT17IHN0eWxlIH1cbiAgICAgICAgICBtdWx0aXBsZVxuICAgICAgICAgIGNsYXNzTmFtZT17IHNlbGVjdENsYXNzIH1cbiAgICAgICAgICBvbkNoYW5nZT17IHRoaXMuZmlsdGVyIH1cbiAgICAgICAgICBvbkNsaWNrPXsgZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpIH1cbiAgICAgICAgICBkZWZhdWx0VmFsdWU9eyB0aGlzLmdldERlZmF1bHRWYWx1ZSgpIH1cbiAgICAgICAgPlxuICAgICAgICAgIHsgdGhpcy5nZXRPcHRpb25zKCkgfVxuICAgICAgICA8L3NlbGVjdD5cbiAgICAgIDwvbGFiZWw+XG4gICAgKTtcbiAgfVxufVxuXG5NdWx0aVNlbGVjdEZpbHRlci5wcm9wVHlwZXMgPSB7XG4gIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBjb2x1bW46IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgb3B0aW9uczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgZmlsdGVyU3RhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGNvbXBhcmF0b3I6IFByb3BUeXBlcy5vbmVPZihbTElLRSwgRVFdKSxcbiAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdpdGhvdXRFbXB0eU9wdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFycmF5LFxuICBjYXNlU2Vuc2l0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ2V0RmlsdGVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuTXVsdGlTZWxlY3RGaWx0ZXIuZGVmYXVsdFByb3BzID0ge1xuICBkZWZhdWx0VmFsdWU6IFtdLFxuICBmaWx0ZXJTdGF0ZToge30sXG4gIGNsYXNzTmFtZTogJycsXG4gIHdpdGhvdXRFbXB0eU9wdGlvbjogZmFsc2UsXG4gIGNvbXBhcmF0b3I6IEVRLFxuICBjYXNlU2Vuc2l0aXZlOiB0cnVlLFxuICBpZDogbnVsbFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTXVsdGlTZWxlY3RGaWx0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcG9uZW50cy9tdWx0aXNlbGVjdC5qcyIsIi8qIGVzbGludCBqc3gtYTExeS9uby1zdGF0aWMtZWxlbWVudC1pbnRlcmFjdGlvbnM6IDAgKi9cbi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbi8qIGVzbGludCBuby1yZXR1cm4tYXNzaWduOiAwICovXG5cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0ICogYXMgQ29tcGFyYXRvciBmcm9tICcuLi9jb21wYXJpc29uJztcbmltcG9ydCB7IEZJTFRFUl9UWVBFLCBGSUxURVJfREVMQVkgfSBmcm9tICcuLi9jb25zdCc7XG5cbmNvbnN0IGxlZ2FsQ29tcGFyYXRvcnMgPSBbXG4gIENvbXBhcmF0b3IuRVEsXG4gIENvbXBhcmF0b3IuTkUsXG4gIENvbXBhcmF0b3IuR1QsXG4gIENvbXBhcmF0b3IuR0UsXG4gIENvbXBhcmF0b3IuTFQsXG4gIENvbXBhcmF0b3IuTEVcbl07XG5cbmNsYXNzIE51bWJlckZpbHRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuY29tcGFyYXRvcnMgPSBwcm9wcy5jb21wYXJhdG9ycyB8fCBsZWdhbENvbXBhcmF0b3JzO1xuICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgbGV0IGlzU2VsZWN0ZWQgPSBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUubnVtYmVyICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb3BzLm9wdGlvbnMgJiYgaXNTZWxlY3RlZCkge1xuICAgICAgaXNTZWxlY3RlZCA9IHByb3BzLm9wdGlvbnMuaW5kZXhPZihwcm9wcy5kZWZhdWx0VmFsdWUubnVtYmVyKSA+IC0xO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0geyBpc1NlbGVjdGVkIH07XG4gICAgdGhpcy5vbkNoYW5nZU51bWJlciA9IHRoaXMub25DaGFuZ2VOdW1iZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uQ2hhbmdlTnVtYmVyU2V0ID0gdGhpcy5vbkNoYW5nZU51bWJlclNldC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25DaGFuZ2VDb21wYXJhdG9yID0gdGhpcy5vbkNoYW5nZUNvbXBhcmF0b3IuYmluZCh0aGlzKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgY29sdW1uLCBvbkZpbHRlciwgZ2V0RmlsdGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSB0aGlzLm51bWJlckZpbHRlckNvbXBhcmF0b3IudmFsdWU7XG4gICAgY29uc3QgbnVtYmVyID0gdGhpcy5udW1iZXJGaWx0ZXIudmFsdWU7XG4gICAgaWYgKGNvbXBhcmF0b3IgJiYgbnVtYmVyKSB7XG4gICAgICBvbkZpbHRlcihjb2x1bW4sIEZJTFRFUl9UWVBFLk5VTUJFUiwgdHJ1ZSkoeyBudW1iZXIsIGNvbXBhcmF0b3IgfSk7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0IG9uRmlsdGVyIGZ1bmN0aW9uIHRvIGFsbG93IHVzZXJzIHRvIGFjY2Vzc1xuICAgIGlmIChnZXRGaWx0ZXIpIHtcbiAgICAgIGdldEZpbHRlcigoZmlsdGVyVmFsKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgaXNTZWxlY3RlZDogKGZpbHRlclZhbCAhPT0gJycpIH0pKTtcbiAgICAgICAgdGhpcy5udW1iZXJGaWx0ZXJDb21wYXJhdG9yLnZhbHVlID0gZmlsdGVyVmFsLmNvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMubnVtYmVyRmlsdGVyLnZhbHVlID0gZmlsdGVyVmFsLm51bWJlcjtcblxuICAgICAgICBvbkZpbHRlcihjb2x1bW4sIEZJTFRFUl9UWVBFLk5VTUJFUikoe1xuICAgICAgICAgIG51bWJlcjogZmlsdGVyVmFsLm51bWJlcixcbiAgICAgICAgICBjb21wYXJhdG9yOiBmaWx0ZXJWYWwuY29tcGFyYXRvclxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICB9XG5cbiAgb25DaGFuZ2VOdW1iZXIoZSkge1xuICAgIGNvbnN0IHsgZGVsYXksIGNvbHVtbiwgb25GaWx0ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgY29tcGFyYXRvciA9IHRoaXMubnVtYmVyRmlsdGVyQ29tcGFyYXRvci52YWx1ZTtcbiAgICBpZiAoY29tcGFyYXRvciA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlclZhbHVlID0gZS50YXJnZXQudmFsdWU7XG4gICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBvbkZpbHRlcihjb2x1bW4sIEZJTFRFUl9UWVBFLk5VTUJFUikoeyBudW1iZXI6IGZpbHRlclZhbHVlLCBjb21wYXJhdG9yIH0pO1xuICAgIH0sIGRlbGF5KTtcbiAgfVxuXG4gIG9uQ2hhbmdlTnVtYmVyU2V0KGUpIHtcbiAgICBjb25zdCB7IGNvbHVtbiwgb25GaWx0ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgY29tcGFyYXRvciA9IHRoaXMubnVtYmVyRmlsdGVyQ29tcGFyYXRvci52YWx1ZTtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBlLnRhcmdldDtcbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGlzU2VsZWN0ZWQ6ICh2YWx1ZSAhPT0gJycpIH0pKTtcbiAgICAvLyBpZiAoY29tcGFyYXRvciA9PT0gJycpIHtcbiAgICAvLyAgIHJldHVybjtcbiAgICAvLyB9XG4gICAgb25GaWx0ZXIoY29sdW1uLCBGSUxURVJfVFlQRS5OVU1CRVIpKHsgbnVtYmVyOiB2YWx1ZSwgY29tcGFyYXRvciB9KTtcbiAgfVxuXG4gIG9uQ2hhbmdlQ29tcGFyYXRvcihlKSB7XG4gICAgY29uc3QgeyBjb2x1bW4sIG9uRmlsdGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5udW1iZXJGaWx0ZXIudmFsdWU7XG4gICAgY29uc3QgY29tcGFyYXRvciA9IGUudGFyZ2V0LnZhbHVlO1xuICAgIC8vIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAvLyAgIHJldHVybjtcbiAgICAvLyB9XG4gICAgb25GaWx0ZXIoY29sdW1uLCBGSUxURVJfVFlQRS5OVU1CRVIpKHsgbnVtYmVyOiB2YWx1ZSwgY29tcGFyYXRvciB9KTtcbiAgfVxuXG4gIGdldERlZmF1bHRDb21wYXJhdG9yKCkge1xuICAgIGNvbnN0IHsgZGVmYXVsdFZhbHVlLCBmaWx0ZXJTdGF0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoZmlsdGVyU3RhdGUgJiYgZmlsdGVyU3RhdGUuZmlsdGVyVmFsKSB7XG4gICAgICByZXR1cm4gZmlsdGVyU3RhdGUuZmlsdGVyVmFsLmNvbXBhcmF0b3I7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgJiYgZGVmYXVsdFZhbHVlLmNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUuY29tcGFyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZ2V0RGVmYXVsdFZhbHVlKCkge1xuICAgIGNvbnN0IHsgZGVmYXVsdFZhbHVlLCBmaWx0ZXJTdGF0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoZmlsdGVyU3RhdGUgJiYgZmlsdGVyU3RhdGUuZmlsdGVyVmFsKSB7XG4gICAgICByZXR1cm4gZmlsdGVyU3RhdGUuZmlsdGVyVmFsLm51bWJlcjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUubnVtYmVyKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlLm51bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZ2V0Q29tcGFyYXRvck9wdGlvbnMoKSB7XG4gICAgY29uc3Qgb3B0aW9uVGFncyA9IFtdO1xuICAgIGNvbnN0IHsgd2l0aG91dEVtcHR5Q29tcGFyYXRvck9wdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXdpdGhvdXRFbXB0eUNvbXBhcmF0b3JPcHRpb24pIHtcbiAgICAgIG9wdGlvblRhZ3MucHVzaCg8b3B0aW9uIGtleT1cIi0xXCIgLz4pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29tcGFyYXRvcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG9wdGlvblRhZ3MucHVzaChcbiAgICAgICAgPG9wdGlvbiBrZXk9eyBpIH0gdmFsdWU9eyB0aGlzLmNvbXBhcmF0b3JzW2ldIH0+XG4gICAgICAgICAgeyB0aGlzLmNvbXBhcmF0b3JzW2ldIH1cbiAgICAgICAgPC9vcHRpb24+XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uVGFncztcbiAgfVxuXG4gIGdldE51bWJlck9wdGlvbnMoKSB7XG4gICAgY29uc3Qgb3B0aW9uVGFncyA9IFtdO1xuICAgIGNvbnN0IHsgb3B0aW9ucywgY29sdW1uLCB3aXRob3V0RW1wdHlOdW1iZXJPcHRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCF3aXRob3V0RW1wdHlOdW1iZXJPcHRpb24pIHtcbiAgICAgIG9wdGlvblRhZ3MucHVzaChcbiAgICAgICAgPG9wdGlvbiBrZXk9XCItMVwiIHZhbHVlPVwiXCI+XG4gICAgICAgICAgeyB0aGlzLnByb3BzLnBsYWNlaG9sZGVyIHx8IGBTZWxlY3QgJHtjb2x1bW4udGV4dH0uLi5gIH1cbiAgICAgICAgPC9vcHRpb24+XG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG9wdGlvblRhZ3MucHVzaCg8b3B0aW9uIGtleT17IGkgfSB2YWx1ZT17IG9wdGlvbnNbaV0gfT57IG9wdGlvbnNbaV0gfTwvb3B0aW9uPik7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25UYWdzO1xuICB9XG5cbiAgYXBwbHlGaWx0ZXIoZmlsdGVyT2JqKSB7XG4gICAgY29uc3QgeyBjb2x1bW4sIG9uRmlsdGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgbnVtYmVyLCBjb21wYXJhdG9yIH0gPSBmaWx0ZXJPYmo7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBpc1NlbGVjdGVkOiAobnVtYmVyICE9PSAnJykgfSkpO1xuICAgIHRoaXMubnVtYmVyRmlsdGVyQ29tcGFyYXRvci52YWx1ZSA9IGNvbXBhcmF0b3I7XG4gICAgdGhpcy5udW1iZXJGaWx0ZXIudmFsdWUgPSBudW1iZXI7XG4gICAgb25GaWx0ZXIoY29sdW1uLCBGSUxURVJfVFlQRS5OVU1CRVIpKHsgbnVtYmVyLCBjb21wYXJhdG9yIH0pO1xuICB9XG5cbiAgY2xlYW5GaWx0ZXJlZCgpIHtcbiAgICBjb25zdCB7IGNvbHVtbiwgb25GaWx0ZXIsIGRlZmF1bHRWYWx1ZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB2YWx1ZSA9IGRlZmF1bHRWYWx1ZSA/IGRlZmF1bHRWYWx1ZS5udW1iZXIgOiAnJztcbiAgICBjb25zdCBjb21wYXJhdG9yID0gZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlLmNvbXBhcmF0b3IgOiAnJztcbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGlzU2VsZWN0ZWQ6ICh2YWx1ZSAhPT0gJycpIH0pKTtcbiAgICB0aGlzLm51bWJlckZpbHRlckNvbXBhcmF0b3IudmFsdWUgPSBjb21wYXJhdG9yO1xuICAgIHRoaXMubnVtYmVyRmlsdGVyLnZhbHVlID0gdmFsdWU7XG4gICAgb25GaWx0ZXIoY29sdW1uLCBGSUxURVJfVFlQRS5OVU1CRVIpKHsgbnVtYmVyOiB2YWx1ZSwgY29tcGFyYXRvciB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGlzU2VsZWN0ZWQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBjb2x1bW4sXG4gICAgICBvcHRpb25zLFxuICAgICAgc3R5bGUsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBudW1iZXJTdHlsZSxcbiAgICAgIG51bWJlckNsYXNzTmFtZSxcbiAgICAgIGNvbXBhcmF0b3JTdHlsZSxcbiAgICAgIGNvbXBhcmF0b3JDbGFzc05hbWUsXG4gICAgICBwbGFjZWhvbGRlclxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHNlbGVjdENsYXNzID0gYFxuICAgICAgc2VsZWN0LWZpbHRlciBcbiAgICAgIG51bWJlci1maWx0ZXItaW5wdXQgXG4gICAgICBmb3JtLWNvbnRyb2wgXG4gICAgICAke251bWJlckNsYXNzTmFtZX0gXG4gICAgICAkeyFpc1NlbGVjdGVkID8gJ3BsYWNlaG9sZGVyLXNlbGVjdGVkJyA6ICcnfVxuICAgIGA7XG5cbiAgICBjb25zdCBjb21wYXJhdG9yRWxtSWQgPSBgbnVtYmVyLWZpbHRlci1jb21wYXJhdG9yLSR7Y29sdW1uLmRhdGFGaWVsZH0ke2lkID8gYC0ke2lkfWAgOiAnJ31gO1xuICAgIGNvbnN0IGlucHV0RWxtSWQgPSBgbnVtYmVyLWZpbHRlci1jb2x1bW4tJHtjb2x1bW4uZGF0YUZpZWxkfSR7aWQgPyBgLSR7aWR9YCA6ICcnfWA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBvbkNsaWNrPXsgZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpIH1cbiAgICAgICAgY2xhc3NOYW1lPXsgYGZpbHRlciBudW1iZXItZmlsdGVyICR7Y2xhc3NOYW1lfWAgfVxuICAgICAgICBzdHlsZT17IHN0eWxlIH1cbiAgICAgID5cbiAgICAgICAgPGxhYmVsXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZmlsdGVyLWxhYmVsXCJcbiAgICAgICAgICBodG1sRm9yPXsgY29tcGFyYXRvckVsbUlkIH1cbiAgICAgICAgPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNyLW9ubHlcIj5GaWx0ZXIgY29tcGFyYXRvcjwvc3Bhbj5cbiAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICByZWY9eyBuID0+IHRoaXMubnVtYmVyRmlsdGVyQ29tcGFyYXRvciA9IG4gfVxuICAgICAgICAgICAgc3R5bGU9eyBjb21wYXJhdG9yU3R5bGUgfVxuICAgICAgICAgICAgaWQ9eyBjb21wYXJhdG9yRWxtSWQgfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXsgYG51bWJlci1maWx0ZXItY29tcGFyYXRvciBmb3JtLWNvbnRyb2wgJHtjb21wYXJhdG9yQ2xhc3NOYW1lfWAgfVxuICAgICAgICAgICAgb25DaGFuZ2U9eyB0aGlzLm9uQ2hhbmdlQ29tcGFyYXRvciB9XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU9eyB0aGlzLmdldERlZmF1bHRDb21wYXJhdG9yKCkgfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHsgdGhpcy5nZXRDb21wYXJhdG9yT3B0aW9ucygpIH1cbiAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgICAge1xuICAgICAgICAgIG9wdGlvbnMgP1xuICAgICAgICAgICAgPGxhYmVsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZpbHRlci1sYWJlbFwiXG4gICAgICAgICAgICAgIGh0bWxGb3I9eyBpbnB1dEVsbUlkIH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic3Itb25seVwiPntgU2VsZWN0ICR7Y29sdW1uLnRleHR9YH08L3NwYW4+XG4gICAgICAgICAgICAgIDxzZWxlY3RcbiAgICAgICAgICAgICAgICByZWY9eyBuID0+IHRoaXMubnVtYmVyRmlsdGVyID0gbiB9XG4gICAgICAgICAgICAgICAgaWQ9eyBpbnB1dEVsbUlkIH1cbiAgICAgICAgICAgICAgICBzdHlsZT17IG51bWJlclN0eWxlIH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9eyBzZWxlY3RDbGFzcyB9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyB0aGlzLm9uQ2hhbmdlTnVtYmVyU2V0IH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9eyB0aGlzLmdldERlZmF1bHRWYWx1ZSgpIH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsgdGhpcy5nZXROdW1iZXJPcHRpb25zKCkgfVxuICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvbGFiZWw+IDpcbiAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPXsgaW5wdXRFbG1JZCB9PlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzci1vbmx5XCI+e2BFbnRlciAke2NvbHVtbi50ZXh0fWB9PC9zcGFuPlxuICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICByZWY9eyBuID0+IHRoaXMubnVtYmVyRmlsdGVyID0gbiB9XG4gICAgICAgICAgICAgICAgaWQ9eyBpbnB1dEVsbUlkIH1cbiAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17IG51bWJlclN0eWxlIH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9eyBgbnVtYmVyLWZpbHRlci1pbnB1dCBmb3JtLWNvbnRyb2wgJHtudW1iZXJDbGFzc05hbWV9YCB9XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9eyBwbGFjZWhvbGRlciB8fCBgRW50ZXIgJHtjb2x1bW4udGV4dH0uLi5gIH1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17IHRoaXMub25DaGFuZ2VOdW1iZXIgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17IHRoaXMuZ2V0RGVmYXVsdFZhbHVlKCkgfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5OdW1iZXJGaWx0ZXIucHJvcFR5cGVzID0ge1xuICBvbkZpbHRlcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgY29sdW1uOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmaWx0ZXJTdGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgb3B0aW9uczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBudW1iZXI6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgICBjb21wYXJhdG9yOiBQcm9wVHlwZXMub25lT2YoWy4uLmxlZ2FsQ29tcGFyYXRvcnMsICcnXSlcbiAgfSksXG4gIGRlbGF5OiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiBlc2xpbnQgY29uc2lzdGVudC1yZXR1cm46IDAgKi9cbiAgY29tcGFyYXRvcnM6IChwcm9wcywgcHJvcE5hbWUpID0+IHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzW3Byb3BOYW1lXS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGV0IGNvbXBhcmF0b3JJc1ZhbGlkID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlZ2FsQ29tcGFyYXRvcnMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgaWYgKGxlZ2FsQ29tcGFyYXRvcnNbal0gPT09IHByb3BzW3Byb3BOYW1lXVtpXSB8fCBwcm9wc1twcm9wTmFtZV1baV0gPT09ICcnKSB7XG4gICAgICAgICAgY29tcGFyYXRvcklzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNvbXBhcmF0b3JJc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYE51bWJlciBjb21wYXJhdG9yIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAgVXNlIG9ubHkgJHtsZWdhbENvbXBhcmF0b3JzfWApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdpdGhvdXRFbXB0eUNvbXBhcmF0b3JPcHRpb246IFByb3BUeXBlcy5ib29sLFxuICB3aXRob3V0RW1wdHlOdW1iZXJPcHRpb246IFByb3BUeXBlcy5ib29sLFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb21wYXJhdG9yU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGNvbXBhcmF0b3JDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG51bWJlclN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBudW1iZXJDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGdldEZpbHRlcjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbk51bWJlckZpbHRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGRlbGF5OiBGSUxURVJfREVMQVksXG4gIG9wdGlvbnM6IHVuZGVmaW5lZCxcbiAgZGVmYXVsdFZhbHVlOiB7XG4gICAgbnVtYmVyOiB1bmRlZmluZWQsXG4gICAgY29tcGFyYXRvcjogJydcbiAgfSxcbiAgZmlsdGVyU3RhdGU6IHt9LFxuICB3aXRob3V0RW1wdHlDb21wYXJhdG9yT3B0aW9uOiBmYWxzZSxcbiAgd2l0aG91dEVtcHR5TnVtYmVyT3B0aW9uOiBmYWxzZSxcbiAgY29tcGFyYXRvcnM6IGxlZ2FsQ29tcGFyYXRvcnMsXG4gIHBsYWNlaG9sZGVyOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIGNsYXNzTmFtZTogJycsXG4gIGNvbXBhcmF0b3JTdHlsZTogdW5kZWZpbmVkLFxuICBjb21wYXJhdG9yQ2xhc3NOYW1lOiAnJyxcbiAgbnVtYmVyU3R5bGU6IHVuZGVmaW5lZCxcbiAgbnVtYmVyQ2xhc3NOYW1lOiAnJyxcbiAgaWQ6IG51bGxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE51bWJlckZpbHRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9jb21wb25lbnRzL251bWJlci5qcyIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbi8qIGVzbGludCBqc3gtYTExeS9uby1zdGF0aWMtZWxlbWVudC1pbnRlcmFjdGlvbnM6IDAgKi9cbi8qIGVzbGludCBuby1yZXR1cm4tYXNzaWduOiAwICovXG4vKiBlc2xpbnQgcHJlZmVyLXRlbXBsYXRlOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJvcFR5cGVzIH0gZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCAqIGFzIENvbXBhcmF0b3IgZnJvbSAnLi4vY29tcGFyaXNvbic7XG5pbXBvcnQgeyBGSUxURVJfVFlQRSB9IGZyb20gJy4uL2NvbnN0JztcblxuY29uc3QgbGVnYWxDb21wYXJhdG9ycyA9IFtcbiAgQ29tcGFyYXRvci5FUSxcbiAgQ29tcGFyYXRvci5ORSxcbiAgQ29tcGFyYXRvci5HVCxcbiAgQ29tcGFyYXRvci5HRSxcbiAgQ29tcGFyYXRvci5MVCxcbiAgQ29tcGFyYXRvci5MRVxuXTtcblxuZnVuY3Rpb24gZGF0ZVBhcnNlcihkKSB7XG4gIHJldHVybiBgJHtkLmdldFVUQ0Z1bGxZZWFyKCl9LSR7KCcwJyArIChkLmdldFVUQ01vbnRoKCkgKyAxKSkuc2xpY2UoLTIpfS0keygnMCcgKyBkLmdldFVUQ0RhdGUoKSkuc2xpY2UoLTIpfWA7XG59XG5cbmNsYXNzIERhdGVGaWx0ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMuY29tcGFyYXRvcnMgPSBwcm9wcy5jb21wYXJhdG9ycyB8fCBsZWdhbENvbXBhcmF0b3JzO1xuICAgIHRoaXMuYXBwbHlGaWx0ZXIgPSB0aGlzLmFwcGx5RmlsdGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkNoYW5nZURhdGUgPSB0aGlzLm9uQ2hhbmdlRGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25DaGFuZ2VDb21wYXJhdG9yID0gdGhpcy5vbkNoYW5nZUNvbXBhcmF0b3IuYmluZCh0aGlzKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgZ2V0RmlsdGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSB0aGlzLmRhdGVGaWx0ZXJDb21wYXJhdG9yLnZhbHVlO1xuICAgIGNvbnN0IGRhdGUgPSB0aGlzLmlucHV0RGF0ZS52YWx1ZTtcbiAgICBpZiAoY29tcGFyYXRvciAmJiBkYXRlKSB7XG4gICAgICB0aGlzLmFwcGx5RmlsdGVyKGRhdGUsIGNvbXBhcmF0b3IsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGV4cG9ydCBvbkZpbHRlciBmdW5jdGlvbiB0byBhbGxvdyB1c2VycyB0byBhY2Nlc3NcbiAgICBpZiAoZ2V0RmlsdGVyKSB7XG4gICAgICBnZXRGaWx0ZXIoKGZpbHRlclZhbCkgPT4ge1xuICAgICAgICBjb25zdCBudWxsYWJsZUZpbHRlclZhbCA9IGZpbHRlclZhbCB8fCB7IGRhdGU6IG51bGwsIGNvbXBhcmF0b3I6IG51bGwgfTtcbiAgICAgICAgdGhpcy5kYXRlRmlsdGVyQ29tcGFyYXRvci52YWx1ZSA9IG51bGxhYmxlRmlsdGVyVmFsLmNvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMuaW5wdXREYXRlLnZhbHVlID0gbnVsbGFibGVGaWx0ZXJWYWwuZGF0ZSA/IGRhdGVQYXJzZXIobnVsbGFibGVGaWx0ZXJWYWwuZGF0ZSkgOiBudWxsO1xuXG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXIobnVsbGFibGVGaWx0ZXJWYWwuZGF0ZSwgbnVsbGFibGVGaWx0ZXJWYWwuY29tcGFyYXRvcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgfVxuXG4gIG9uQ2hhbmdlRGF0ZShlKSB7XG4gICAgY29uc3QgY29tcGFyYXRvciA9IHRoaXMuZGF0ZUZpbHRlckNvbXBhcmF0b3IudmFsdWU7XG4gICAgY29uc3QgZmlsdGVyVmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICB0aGlzLmFwcGx5RmlsdGVyKGZpbHRlclZhbHVlLCBjb21wYXJhdG9yKTtcbiAgfVxuXG4gIG9uQ2hhbmdlQ29tcGFyYXRvcihlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0RGF0ZS52YWx1ZTtcbiAgICBjb25zdCBjb21wYXJhdG9yID0gZS50YXJnZXQudmFsdWU7XG4gICAgdGhpcy5hcHBseUZpbHRlcih2YWx1ZSwgY29tcGFyYXRvcik7XG4gIH1cblxuICBnZXRDb21wYXJhdG9yT3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25UYWdzID0gW107XG4gICAgY29uc3QgeyB3aXRob3V0RW1wdHlDb21wYXJhdG9yT3B0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghd2l0aG91dEVtcHR5Q29tcGFyYXRvck9wdGlvbikge1xuICAgICAgb3B0aW9uVGFncy5wdXNoKDxvcHRpb24ga2V5PVwiLTFcIiAvPik7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb21wYXJhdG9ycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb3B0aW9uVGFncy5wdXNoKFxuICAgICAgICA8b3B0aW9uIGtleT17IGkgfSB2YWx1ZT17IHRoaXMuY29tcGFyYXRvcnNbaV0gfT5cbiAgICAgICAgICB7IHRoaXMuY29tcGFyYXRvcnNbaV0gfVxuICAgICAgICA8L29wdGlvbj5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25UYWdzO1xuICB9XG5cbiAgZ2V0RGVmYXVsdENvbXBhcmF0b3IoKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0VmFsdWUsIGZpbHRlclN0YXRlIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChmaWx0ZXJTdGF0ZSAmJiBmaWx0ZXJTdGF0ZS5maWx0ZXJWYWwpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJTdGF0ZS5maWx0ZXJWYWwuY29tcGFyYXRvcjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUuY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZS5jb21wYXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBnZXREZWZhdWx0RGF0ZSgpIHtcbiAgICAvLyBTZXQgdGhlIGFwcHJvcHJpYXRlIGZvcm1hdCBmb3IgdGhlIGlucHV0IHR5cGU9ZGF0ZSwgaS5lLiBcIllZWVktTU0tRERcIlxuICAgIGNvbnN0IHsgZGVmYXVsdFZhbHVlLCBmaWx0ZXJTdGF0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoZmlsdGVyU3RhdGUgJiYgZmlsdGVyU3RhdGUuZmlsdGVyVmFsICYmIGZpbHRlclN0YXRlLmZpbHRlclZhbC5kYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZVBhcnNlcihmaWx0ZXJTdGF0ZS5maWx0ZXJWYWwuZGF0ZSk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgJiYgZGVmYXVsdFZhbHVlLmRhdGUpIHtcbiAgICAgIHJldHVybiBkYXRlUGFyc2VyKG5ldyBEYXRlKGRlZmF1bHRWYWx1ZS5kYXRlKSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGFwcGx5RmlsdGVyKHZhbHVlLCBjb21wYXJhdG9yLCBpc0luaXRpYWwpIHtcbiAgICAvLyBpZiAoIWNvbXBhcmF0b3IgfHwgIXZhbHVlKSB7XG4gICAgLy8gIHJldHVybjtcbiAgICAvLyB9XG4gICAgY29uc3QgeyBjb2x1bW4sIG9uRmlsdGVyLCBkZWxheSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBleGVjdXRlID0gKCkgPT4ge1xuICAgICAgLy8gSW5jb21pbmcgdmFsdWUgc2hvdWxkIGFsd2F5cyBiZSBhIHN0cmluZywgYW5kIHRoZSBkZWZhdWx0RGF0ZVxuICAgICAgLy8gYWJvdmUgaXMgaW1wbGVtZW50ZWQgYXMgYW4gZW1wdHkgc3RyaW5nLCBzbyB3ZSBjYW4ganVzdCBjaGVjayBmb3IgdGhhdC5cbiAgICAgIC8vIGluc3RlYWQgb2YgcGFyc2luZyBhbiBpbnZhbGlkIERhdGUuIFRoZSBmaWx0ZXIgZnVuY3Rpb24gd2lsbCBpbnRlcnByZXRcbiAgICAgIC8vIG51bGwgYXMgYW4gZW1wdHkgZGF0ZSBmaWVsZFxuICAgICAgY29uc3QgZGF0ZSA9IHZhbHVlID09PSAnJyA/IG51bGwgOiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICBvbkZpbHRlcihjb2x1bW4sIEZJTFRFUl9UWVBFLkRBVEUsIGlzSW5pdGlhbCkoeyBkYXRlLCBjb21wYXJhdG9yIH0pO1xuICAgIH07XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHsgZXhlY3V0ZSgpOyB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4ZWN1dGUoKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIGNvbHVtbjogeyBkYXRhRmllbGQsIHRleHQgfSxcbiAgICAgIHN0eWxlLFxuICAgICAgY29tcGFyYXRvclN0eWxlLFxuICAgICAgZGF0ZVN0eWxlLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgY29tcGFyYXRvckNsYXNzTmFtZSxcbiAgICAgIGRhdGVDbGFzc05hbWVcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNvbXBhcmF0b3JFbG1JZCA9IGBkYXRlLWZpbHRlci1jb21wYXJhdG9yLSR7ZGF0YUZpZWxkfSR7aWQgPyBgLSR7aWR9YCA6ICcnfWA7XG4gICAgY29uc3QgaW5wdXRFbG1JZCA9IGBkYXRlLWZpbHRlci1jb2x1bW4tJHtkYXRhRmllbGR9JHtpZCA/IGAtJHtpZH1gIDogJyd9YDtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIG9uQ2xpY2s9eyBlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCkgfVxuICAgICAgICBjbGFzc05hbWU9eyBgZmlsdGVyIGRhdGUtZmlsdGVyICR7Y2xhc3NOYW1lfWAgfVxuICAgICAgICBzdHlsZT17IHN0eWxlIH1cbiAgICAgID5cbiAgICAgICAgPGxhYmVsXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZmlsdGVyLWxhYmVsXCJcbiAgICAgICAgICBodG1sRm9yPXsgY29tcGFyYXRvckVsbUlkIH1cbiAgICAgICAgPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNyLW9ubHlcIj5GaWx0ZXIgY29tcGFyYXRvcjwvc3Bhbj5cbiAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICByZWY9eyBuID0+IHRoaXMuZGF0ZUZpbHRlckNvbXBhcmF0b3IgPSBuIH1cbiAgICAgICAgICAgIGlkPXsgY29tcGFyYXRvckVsbUlkIH1cbiAgICAgICAgICAgIHN0eWxlPXsgY29tcGFyYXRvclN0eWxlIH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17IGBkYXRlLWZpbHRlci1jb21wYXJhdG9yIGZvcm0tY29udHJvbCAke2NvbXBhcmF0b3JDbGFzc05hbWV9YCB9XG4gICAgICAgICAgICBvbkNoYW5nZT17IHRoaXMub25DaGFuZ2VDb21wYXJhdG9yIH1cbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17IHRoaXMuZ2V0RGVmYXVsdENvbXBhcmF0b3IoKSB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgeyB0aGlzLmdldENvbXBhcmF0b3JPcHRpb25zKCkgfVxuICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8bGFiZWwgaHRtbEZvcj17IGlucHV0RWxtSWQgfT5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzci1vbmx5XCI+RW50ZXIgJHsgdGV4dCB9PC9zcGFuPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgcmVmPXsgbiA9PiB0aGlzLmlucHV0RGF0ZSA9IG4gfVxuICAgICAgICAgICAgaWQ9eyBpbnB1dEVsbUlkIH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17IGBmaWx0ZXIgZGF0ZS1maWx0ZXItaW5wdXQgZm9ybS1jb250cm9sICR7ZGF0ZUNsYXNzTmFtZX1gIH1cbiAgICAgICAgICAgIHN0eWxlPXsgZGF0ZVN0eWxlIH1cbiAgICAgICAgICAgIHR5cGU9XCJkYXRlXCJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXsgdGhpcy5vbkNoYW5nZURhdGUgfVxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9eyBwbGFjZWhvbGRlciB8fCBgRW50ZXIgJHt0ZXh0fS4uLmAgfVxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXsgdGhpcy5nZXREZWZhdWx0RGF0ZSgpIH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2xhYmVsPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5EYXRlRmlsdGVyLnByb3BUeXBlcyA9IHtcbiAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGNvbHVtbjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgZmlsdGVyU3RhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGRlbGF5OiBQcm9wVHlwZXMubnVtYmVyLFxuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZGF0ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIGNvbXBhcmF0b3I6IFByb3BUeXBlcy5vbmVPZihbLi4ubGVnYWxDb21wYXJhdG9ycywgJyddKVxuICB9KSxcbiAgLyogZXNsaW50IGNvbnNpc3RlbnQtcmV0dXJuOiAwICovXG4gIGNvbXBhcmF0b3JzOiAocHJvcHMsIHByb3BOYW1lKSA9PiB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1twcm9wTmFtZV0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxldCBjb21wYXJhdG9ySXNWYWxpZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZWdhbENvbXBhcmF0b3JzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChsZWdhbENvbXBhcmF0b3JzW2pdID09PSBwcm9wc1twcm9wTmFtZV1baV0gfHwgcHJvcHNbcHJvcE5hbWVdW2ldID09PSAnJykge1xuICAgICAgICAgIGNvbXBhcmF0b3JJc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjb21wYXJhdG9ySXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBEYXRlIGNvbXBhcmF0b3IgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICBVc2Ugb25seSAke2xlZ2FsQ29tcGFyYXRvcnN9YCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgd2l0aG91dEVtcHR5Q29tcGFyYXRvck9wdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjb21wYXJhdG9yU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGRhdGVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb21wYXJhdG9yQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBkYXRlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBnZXRGaWx0ZXI6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5EYXRlRmlsdGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgZGVsYXk6IDAsXG4gIGRlZmF1bHRWYWx1ZToge1xuICAgIGRhdGU6IHVuZGVmaW5lZCxcbiAgICBjb21wYXJhdG9yOiAnJ1xuICB9LFxuICBmaWx0ZXJTdGF0ZToge30sXG4gIHdpdGhvdXRFbXB0eUNvbXBhcmF0b3JPcHRpb246IGZhbHNlLFxuICBjb21wYXJhdG9yczogbGVnYWxDb21wYXJhdG9ycyxcbiAgcGxhY2Vob2xkZXI6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgY2xhc3NOYW1lOiAnJyxcbiAgY29tcGFyYXRvclN0eWxlOiB1bmRlZmluZWQsXG4gIGNvbXBhcmF0b3JDbGFzc05hbWU6ICcnLFxuICBkYXRlU3R5bGU6IHVuZGVmaW5lZCxcbiAgZGF0ZUNsYXNzTmFtZTogJycsXG4gIGlkOiBudWxsXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IERhdGVGaWx0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcG9uZW50cy9kYXRlLmpzIiwiLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbi8qIGVzbGludCBjYW1lbGNhc2U6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgeyBmaWx0ZXJzIH0gZnJvbSAnLi9maWx0ZXInO1xuaW1wb3J0IHsgTElLRSwgRVEgfSBmcm9tICcuL2NvbXBhcmlzb24nO1xuaW1wb3J0IHsgRklMVEVSX1RZUEUgfSBmcm9tICcuL2NvbnN0JztcblxuZXhwb3J0IGRlZmF1bHQgKFxuICBfLFxuICBpc1JlbW90ZUZpbHRlcmluZyxcbiAgaGFuZGxlRmlsdGVyQ2hhbmdlXG4pID0+IHtcbiAgY29uc3QgRmlsdGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoKTtcblxuICBjbGFzcyBGaWx0ZXJQcm92aWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICAgICAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gICAgICBkYXRhQ2hhbmdlTGlzdGVuZXI6IFByb3BUeXBlcy5vYmplY3RcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5jdXJyRmlsdGVycyA9IHt9O1xuICAgICAgdGhpcy5jbGVhckZpbHRlcnMgPSB7fTtcbiAgICAgIHRoaXMub25GaWx0ZXIgPSB0aGlzLm9uRmlsdGVyLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmRvRmlsdGVyID0gdGhpcy5kb0ZpbHRlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbkV4dGVybmFsRmlsdGVyID0gdGhpcy5vbkV4dGVybmFsRmlsdGVyLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmRhdGEgPSBwcm9wcy5kYXRhO1xuICAgICAgdGhpcy5pc0VtaXREYXRhQ2hhbmdlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAoaXNSZW1vdGVGaWx0ZXJpbmcoKSAmJiBPYmplY3Qua2V5cyh0aGlzLmN1cnJGaWx0ZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGhhbmRsZUZpbHRlckNoYW5nZSh0aGlzLmN1cnJGaWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvbkZpbHRlcihjb2x1bW4sIGZpbHRlclR5cGUsIGluaXRpYWxpemUgPSBmYWxzZSkge1xuICAgICAgcmV0dXJuIChmaWx0ZXJWYWwpID0+IHtcbiAgICAgICAgLy8gd2F0Y2ggb3V0IGhlcmUgaWYgbWlncmF0aW9uIHRvIGNvbnRleHQgQVBJLCAjMzM0XG4gICAgICAgIGNvbnN0IGN1cnJGaWx0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jdXJyRmlsdGVycyk7XG4gICAgICAgIHRoaXMuY2xlYXJGaWx0ZXJzID0ge307XG4gICAgICAgIGNvbnN0IHsgZGF0YUZpZWxkLCBmaWx0ZXIgfSA9IGNvbHVtbjtcblxuICAgICAgICBjb25zdCBuZWVkQ2xlYXJGaWx0ZXJzID1cbiAgICAgICAgICAhXy5pc0RlZmluZWQoZmlsdGVyVmFsKSB8fFxuICAgICAgICAgIGZpbHRlclZhbCA9PT0gJycgfHxcbiAgICAgICAgICBmaWx0ZXJWYWwubGVuZ3RoID09PSAwO1xuXG4gICAgICAgIGlmIChuZWVkQ2xlYXJGaWx0ZXJzKSB7XG4gICAgICAgICAgZGVsZXRlIGN1cnJGaWx0ZXJzW2RhdGFGaWVsZF07XG4gICAgICAgICAgdGhpcy5jbGVhckZpbHRlcnMgPSB7IFtkYXRhRmllbGRdOiB7IGNsZWFyOiB0cnVlLCBmaWx0ZXJWYWwgfSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNlbGVjdCBkZWZhdWx0IGNvbXBhcmF0b3IgaXMgRVEsIG90aGVycyBhcmUgTElLRVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbXBhcmF0b3IgPSAoZmlsdGVyVHlwZSA9PT0gRklMVEVSX1RZUEUuU0VMRUNUID8gRVEgOiBMSUtFKSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZVxuICAgICAgICAgIH0gPSBmaWx0ZXIucHJvcHM7XG4gICAgICAgICAgY3VyckZpbHRlcnNbZGF0YUZpZWxkXSA9IHsgZmlsdGVyVmFsLCBmaWx0ZXJUeXBlLCBjb21wYXJhdG9yLCBjYXNlU2Vuc2l0aXZlIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJGaWx0ZXJzID0gY3VyckZpbHRlcnM7XG5cbiAgICAgICAgaWYgKGlzUmVtb3RlRmlsdGVyaW5nKCkpIHtcbiAgICAgICAgICBpZiAoIWluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIGhhbmRsZUZpbHRlckNoYW5nZSh0aGlzLmN1cnJGaWx0ZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9GaWx0ZXIodGhpcy5wcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIG9uRXh0ZXJuYWxGaWx0ZXIoY29sdW1uLCBmaWx0ZXJUeXBlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMub25GaWx0ZXIoY29sdW1uLCBmaWx0ZXJUeXBlKSh2YWx1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGdldEZpbHRlcmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIC8vIGxldCBuZXh0RGF0YSA9IG5leHRQcm9wcy5kYXRhO1xuICAgICAgaWYgKCFpc1JlbW90ZUZpbHRlcmluZygpICYmICFfLmlzRXF1YWwobmV4dFByb3BzLmRhdGEsIHRoaXMuZGF0YSkpIHtcbiAgICAgICAgdGhpcy5kb0ZpbHRlcihuZXh0UHJvcHMsIHRoaXMuaXNFbWl0RGF0YUNoYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXh0UHJvcHMuZGF0YTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkb0ZpbHRlcihwcm9wcywgaWdub3JlRW1pdERhdGFDaGFuZ2UgPSBmYWxzZSkge1xuICAgICAgY29uc3QgeyBkYXRhQ2hhbmdlTGlzdGVuZXIsIGRhdGEsIGNvbHVtbnMgfSA9IHByb3BzO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZmlsdGVycyhkYXRhLCBjb2x1bW5zLCBfKSh0aGlzLmN1cnJGaWx0ZXJzLCB0aGlzLmNsZWFyRmlsdGVycyk7XG4gICAgICB0aGlzLmRhdGEgPSByZXN1bHQ7XG4gICAgICBpZiAoZGF0YUNoYW5nZUxpc3RlbmVyICYmICFpZ25vcmVFbWl0RGF0YUNoYW5nZSkge1xuICAgICAgICB0aGlzLmlzRW1pdERhdGFDaGFuZ2UgPSB0cnVlO1xuICAgICAgICBkYXRhQ2hhbmdlTGlzdGVuZXIuZW1pdCgnZmlsdGVyQ2hhbmdlZCcsIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc0VtaXREYXRhQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8RmlsdGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17IHtcbiAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgb25GaWx0ZXI6IHRoaXMub25GaWx0ZXIsXG4gICAgICAgICAgb25FeHRlcm5hbEZpbHRlcjogdGhpcy5vbkV4dGVybmFsRmlsdGVyLFxuICAgICAgICAgIGN1cnJGaWx0ZXJzOiB0aGlzLmN1cnJGaWx0ZXJzXG4gICAgICAgIH0gfVxuICAgICAgICA+XG4gICAgICAgICAgeyB0aGlzLnByb3BzLmNoaWxkcmVuIH1cbiAgICAgICAgPC9GaWx0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFByb3ZpZGVyOiBGaWx0ZXJQcm92aWRlcixcbiAgICBDb25zdW1lcjogRmlsdGVyQ29udGV4dC5Db25zdW1lclxuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9jb250ZXh0LmpzIiwiLyogZXNsaW50IGVxZXFlcTogMCAqL1xuLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cbmltcG9ydCB7IEZJTFRFUl9UWVBFIH0gZnJvbSAnLi9jb25zdCc7XG5pbXBvcnQgeyBMSUtFLCBFUSwgTkUsIEdULCBHRSwgTFQsIExFIH0gZnJvbSAnLi9jb21wYXJpc29uJztcblxuZXhwb3J0IGNvbnN0IGZpbHRlckJ5VGV4dCA9IF8gPT4gKFxuICBkYXRhLFxuICBkYXRhRmllbGQsXG4gIHsgZmlsdGVyVmFsOiB1c2VySW5wdXQgPSAnJywgY29tcGFyYXRvciA9IExJS0UsIGNhc2VTZW5zaXRpdmUgfSxcbiAgY3VzdG9tRmlsdGVyVmFsdWVcbikgPT4ge1xuICAvLyBtYWtlIHN1cmUgZmlsdGVyIHZhbHVlIHRvIGJlIGEgc3RyaW5nXG4gIGNvbnN0IGZpbHRlclZhbCA9IHVzZXJJbnB1dC50b1N0cmluZygpO1xuXG4gIHJldHVybiAoXG4gICAgZGF0YS5maWx0ZXIoKHJvdykgPT4ge1xuICAgICAgbGV0IGNlbGwgPSBfLmdldChyb3csIGRhdGFGaWVsZCk7XG4gICAgICBpZiAoY3VzdG9tRmlsdGVyVmFsdWUpIHtcbiAgICAgICAgY2VsbCA9IGN1c3RvbUZpbHRlclZhbHVlKGNlbGwsIHJvdyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjZWxsU3RyID0gXy5pc0RlZmluZWQoY2VsbCkgPyBjZWxsLnRvU3RyaW5nKCkgOiAnJztcbiAgICAgIGlmIChjb21wYXJhdG9yID09PSBFUSkge1xuICAgICAgICByZXR1cm4gY2VsbFN0ciA9PT0gZmlsdGVyVmFsO1xuICAgICAgfVxuICAgICAgaWYgKGNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIGNlbGxTdHIuaW5jbHVkZXMoZmlsdGVyVmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNlbGxTdHIudG9Mb2NhbGVVcHBlckNhc2UoKS5pbmRleE9mKGZpbHRlclZhbC50b0xvY2FsZVVwcGVyQ2FzZSgpKSAhPT0gLTE7XG4gICAgfSlcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJCeU51bWJlciA9IF8gPT4gKFxuICBkYXRhLFxuICBkYXRhRmllbGQsXG4gIHsgZmlsdGVyVmFsOiB7IGNvbXBhcmF0b3IsIG51bWJlciB9IH0sXG4gIGN1c3RvbUZpbHRlclZhbHVlXG4pID0+IChcbiAgZGF0YS5maWx0ZXIoKHJvdykgPT4ge1xuICAgIGlmIChudW1iZXIgPT09ICcnIHx8ICFjb21wYXJhdG9yKSByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgdmFsaWQgPSB0cnVlO1xuICAgIGxldCBjZWxsID0gXy5nZXQocm93LCBkYXRhRmllbGQpO1xuICAgIGlmIChjdXN0b21GaWx0ZXJWYWx1ZSkge1xuICAgICAgY2VsbCA9IGN1c3RvbUZpbHRlclZhbHVlKGNlbGwsIHJvdyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjb21wYXJhdG9yKSB7XG4gICAgICBjYXNlIEVROiB7XG4gICAgICAgIGlmIChjZWxsICE9IG51bWJlcikge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEdUOiB7XG4gICAgICAgIGlmIChjZWxsIDw9IG51bWJlcikge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEdFOiB7XG4gICAgICAgIGlmIChjZWxsIDwgbnVtYmVyKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgTFQ6IHtcbiAgICAgICAgaWYgKGNlbGwgPj0gbnVtYmVyKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgTEU6IHtcbiAgICAgICAgaWYgKGNlbGwgPiBudW1iZXIpIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBORToge1xuICAgICAgICBpZiAoY2VsbCA9PSBudW1iZXIpIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdOdW1iZXIgY29tcGFyYXRvciBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH0pXG4pO1xuXG5leHBvcnQgY29uc3QgZmlsdGVyQnlEYXRlID0gXyA9PiAoXG4gIGRhdGEsXG4gIGRhdGFGaWVsZCxcbiAgeyBmaWx0ZXJWYWw6IHsgY29tcGFyYXRvciwgZGF0ZSB9IH0sXG4gIGN1c3RvbUZpbHRlclZhbHVlXG4pID0+IHtcbiAgaWYgKCFkYXRlIHx8ICFjb21wYXJhdG9yKSByZXR1cm4gZGF0YTtcbiAgY29uc3QgZmlsdGVyRGF0ZSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICBjb25zdCBmaWx0ZXJNb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgY29uc3QgZmlsdGVyWWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcblxuICByZXR1cm4gZGF0YS5maWx0ZXIoKHJvdykgPT4ge1xuICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgbGV0IGNlbGwgPSBfLmdldChyb3csIGRhdGFGaWVsZCk7XG5cbiAgICBpZiAoY3VzdG9tRmlsdGVyVmFsdWUpIHtcbiAgICAgIGNlbGwgPSBjdXN0b21GaWx0ZXJWYWx1ZShjZWxsLCByb3cpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2VsbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGNlbGwgPSBuZXcgRGF0ZShjZWxsKTtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXREYXRlID0gY2VsbC5nZXRVVENEYXRlKCk7XG4gICAgY29uc3QgdGFyZ2V0TW9udGggPSBjZWxsLmdldFVUQ01vbnRoKCk7XG4gICAgY29uc3QgdGFyZ2V0WWVhciA9IGNlbGwuZ2V0VVRDRnVsbFllYXIoKTtcblxuXG4gICAgc3dpdGNoIChjb21wYXJhdG9yKSB7XG4gICAgICBjYXNlIEVROiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBmaWx0ZXJEYXRlICE9PSB0YXJnZXREYXRlIHx8XG4gICAgICAgICAgZmlsdGVyTW9udGggIT09IHRhcmdldE1vbnRoIHx8XG4gICAgICAgICAgZmlsdGVyWWVhciAhPT0gdGFyZ2V0WWVhclxuICAgICAgICApIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBHVDoge1xuICAgICAgICBpZiAoY2VsbCA8PSBkYXRlKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgR0U6IHtcbiAgICAgICAgaWYgKHRhcmdldFllYXIgPCBmaWx0ZXJZZWFyKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRZZWFyID09PSBmaWx0ZXJZZWFyICYmXG4gICAgICAgICAgdGFyZ2V0TW9udGggPCBmaWx0ZXJNb250aCkge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0WWVhciA9PT0gZmlsdGVyWWVhciAmJlxuICAgICAgICAgIHRhcmdldE1vbnRoID09PSBmaWx0ZXJNb250aCAmJlxuICAgICAgICAgIHRhcmdldERhdGUgPCBmaWx0ZXJEYXRlKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgTFQ6IHtcbiAgICAgICAgaWYgKGNlbGwgPj0gZGF0ZSkge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIExFOiB7XG4gICAgICAgIGlmICh0YXJnZXRZZWFyID4gZmlsdGVyWWVhcikge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0WWVhciA9PT0gZmlsdGVyWWVhciAmJlxuICAgICAgICAgIHRhcmdldE1vbnRoID4gZmlsdGVyTW9udGgpIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFllYXIgPT09IGZpbHRlclllYXIgJiZcbiAgICAgICAgICB0YXJnZXRNb250aCA9PT0gZmlsdGVyTW9udGggJiZcbiAgICAgICAgICB0YXJnZXREYXRlID4gZmlsdGVyRGF0ZSkge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIE5FOiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBmaWx0ZXJEYXRlID09PSB0YXJnZXREYXRlICYmXG4gICAgICAgICAgZmlsdGVyTW9udGggPT09IHRhcmdldE1vbnRoICYmXG4gICAgICAgICAgZmlsdGVyWWVhciA9PT0gdGFyZ2V0WWVhclxuICAgICAgICApIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdEYXRlIGNvbXBhcmF0b3IgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJCeUFycmF5ID0gXyA9PiAoXG4gIGRhdGEsXG4gIGRhdGFGaWVsZCxcbiAgeyBmaWx0ZXJWYWwsIGNvbXBhcmF0b3IgfVxuKSA9PiB7XG4gIGlmIChmaWx0ZXJWYWwubGVuZ3RoID09PSAwKSByZXR1cm4gZGF0YTtcbiAgY29uc3QgcmVmaW5lZEZpbHRlclZhbCA9IGZpbHRlclZhbFxuICAgIC5maWx0ZXIoeCA9PiBfLmlzRGVmaW5lZCh4KSlcbiAgICAubWFwKHggPT4geC50b1N0cmluZygpKTtcbiAgcmV0dXJuIGRhdGEuZmlsdGVyKChyb3cpID0+IHtcbiAgICBjb25zdCBjZWxsID0gXy5nZXQocm93LCBkYXRhRmllbGQpO1xuICAgIGxldCBjZWxsU3RyID0gXy5pc0RlZmluZWQoY2VsbCkgPyBjZWxsLnRvU3RyaW5nKCkgOiAnJztcbiAgICBpZiAoY29tcGFyYXRvciA9PT0gRVEpIHtcbiAgICAgIHJldHVybiByZWZpbmVkRmlsdGVyVmFsLmluZGV4T2YoY2VsbFN0cikgIT09IC0xO1xuICAgIH1cbiAgICBjZWxsU3RyID0gY2VsbFN0ci50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICAgIHJldHVybiByZWZpbmVkRmlsdGVyVmFsLnNvbWUoaXRlbSA9PiBjZWxsU3RyLmluZGV4T2YoaXRlbS50b0xvY2FsZVVwcGVyQ2FzZSgpKSAhPT0gLTEpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJGYWN0b3J5ID0gXyA9PiAoZmlsdGVyVHlwZSkgPT4ge1xuICBsZXQgZmlsdGVyRm47XG4gIHN3aXRjaCAoZmlsdGVyVHlwZSkge1xuICAgIGNhc2UgRklMVEVSX1RZUEUuVEVYVDpcbiAgICBjYXNlIEZJTFRFUl9UWVBFLlNFTEVDVDpcbiAgICAgIGZpbHRlckZuID0gZmlsdGVyQnlUZXh0KF8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGSUxURVJfVFlQRS5NVUxUSVNFTEVDVDpcbiAgICAgIGZpbHRlckZuID0gZmlsdGVyQnlBcnJheShfKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRklMVEVSX1RZUEUuTlVNQkVSOlxuICAgICAgZmlsdGVyRm4gPSBmaWx0ZXJCeU51bWJlcihfKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRklMVEVSX1RZUEUuREFURTpcbiAgICAgIGZpbHRlckZuID0gZmlsdGVyQnlEYXRlKF8pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZpbHRlckZuID0gZmlsdGVyQnlUZXh0KF8pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJGbjtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJzID0gKGRhdGEsIGNvbHVtbnMsIF8pID0+IChjdXJyRmlsdGVycywgY2xlYXJGaWx0ZXJzID0ge30pID0+IHtcbiAgY29uc3QgZmFjdG9yeSA9IGZpbHRlckZhY3RvcnkoXyk7XG4gIGNvbnN0IGZpbHRlclN0YXRlID0geyAuLi5jbGVhckZpbHRlcnMsIC4uLmN1cnJGaWx0ZXJzIH07XG4gIGxldCByZXN1bHQgPSBkYXRhO1xuICBsZXQgZmlsdGVyRm47XG4gIE9iamVjdC5rZXlzKGZpbHRlclN0YXRlKS5mb3JFYWNoKChkYXRhRmllbGQpID0+IHtcbiAgICBsZXQgY3VycmVudFJlc3VsdDtcbiAgICBsZXQgZmlsdGVyVmFsdWU7XG4gICAgbGV0IGN1c3RvbUZpbHRlcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChjb2x1bW5zW2ldLmRhdGFGaWVsZCA9PT0gZGF0YUZpZWxkKSB7XG4gICAgICAgIGZpbHRlclZhbHVlID0gY29sdW1uc1tpXS5maWx0ZXJWYWx1ZTtcbiAgICAgICAgaWYgKGNvbHVtbnNbaV0uZmlsdGVyKSB7XG4gICAgICAgICAgY3VzdG9tRmlsdGVyID0gY29sdW1uc1tpXS5maWx0ZXIucHJvcHMub25GaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsZWFyRmlsdGVyc1tkYXRhRmllbGRdICYmIGN1c3RvbUZpbHRlcikge1xuICAgICAgY3VycmVudFJlc3VsdCA9IGN1c3RvbUZpbHRlcihjbGVhckZpbHRlcnNbZGF0YUZpZWxkXS5maWx0ZXJWYWwsIHJlc3VsdCk7XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRSZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlc3VsdCA9IGN1cnJlbnRSZXN1bHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbHRlck9iaiA9IGZpbHRlclN0YXRlW2RhdGFGaWVsZF07XG4gICAgICBmaWx0ZXJGbiA9IGZhY3RvcnkoZmlsdGVyT2JqLmZpbHRlclR5cGUpO1xuICAgICAgaWYgKGN1c3RvbUZpbHRlcikge1xuICAgICAgICBjdXJyZW50UmVzdWx0ID0gY3VzdG9tRmlsdGVyKGZpbHRlck9iai5maWx0ZXJWYWwsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRSZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlc3VsdCA9IGZpbHRlckZuKHJlc3VsdCwgZGF0YUZpZWxkLCBmaWx0ZXJPYmosIGZpbHRlclZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGN1cnJlbnRSZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvZmlsdGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==
//# sourceMappingURL=react-bootstrap-table2-filter.js.map